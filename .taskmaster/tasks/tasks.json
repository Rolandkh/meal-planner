{
  "master": {
    "tasks": [
      {
        "id": 100,
        "title": "Implement Diet Profile Filter Utility",
        "description": "Create a utility to filter recipes by diet profiles, handle compound ingredient splitting, detect profile conflicts, and check recipe compatibility.",
        "details": "Create src/utils/dietProfileFilter.js with the following functions:\n1. filterByDietProfile(catalog, profileId) - Filter catalog recipes by compatibility with a specific diet profile\n2. isCompatibleWithProfiles(recipe, profileIds) - Check if a recipe is compatible with multiple profiles\n3. hasProfileConflicts(profileIds) - Detect fundamental conflicts between profiles (e.g., Keto vs Vegan)\n4. splitCompoundIngredients(ingredientString) - Split compound ingredients like 'salt and pepper'\n\nImplement fuzzy matching for ingredient names and handle edge cases like 'salt and pepper'. Use the existing diet profiles from src/data/dietProfiles.json to determine compatibility rules.\n\nExample implementation:\n```javascript\nexport function filterByDietProfile(catalog, profileId) {\n  const profile = getDietProfile(profileId);\n  return catalog.filter(recipe => {\n    // Check if recipe tags match profile requirements\n    const dietCompatible = recipe.tags.diets.includes(profileId);\n    // Check if recipe contains excluded ingredients\n    const noExcludedIngredients = !hasExcludedIngredients(recipe, profile.excludedIngredients);\n    return dietCompatible && noExcludedIngredients;\n  });\n}\n\nexport function hasProfileConflicts(profileIds) {\n  const conflicts = [];\n  const profiles = profileIds.map(id => getDietProfile(id));\n  \n  // Check for fundamental conflicts (e.g., Keto vs Vegan)\n  for (let i = 0; i < profiles.length; i++) {\n    for (let j = i + 1; j < profiles.length; j++) {\n      if (areProfilesConflicting(profiles[i], profiles[j])) {\n        conflicts.push([profileIds[i], profileIds[j]]);\n      }\n    }\n  }\n  \n  return {\n    hasConflicts: conflicts.length > 0,\n    conflictPairs: conflicts\n  };\n}\n```",
        "testStrategy": "1. Unit test each function with various diet profiles and recipes\n2. Test compound ingredient splitting with various formats ('salt and pepper', 'flour and water', etc.)\n3. Test conflict detection with known conflicting profiles (Keto + Vegan)\n4. Test recipe compatibility with edge cases (recipes that almost match a profile)\n5. Integration test with the meal generation flow to ensure proper filtering",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-10T04:57:11.567Z"
      },
      {
        "id": 101,
        "title": "Implement Multi-Profile Meal Generation",
        "description": "Enhance the meal generation system to handle households with conflicting diet profiles by generating multiple recipes when needed.",
        "status": "done",
        "dependencies": [
          "100"
        ],
        "priority": "high",
        "details": "Modify the meal generation API to:\n1. Group eaters by compatible diet profiles using the diet profile filter utility\n2. Generate separate recipes for conflicting profiles (e.g., Keto and Vegan)\n3. Label each recipe with target eaters\n4. Ensure shopping list includes ingredients for all variants\n\nUpdate the meal schema to include targetEaters and dietProfileTags fields.\n\nImplementation steps:\n1. Enhance the API request handler to detect profile conflicts\n2. Modify the AI system prompt to include instructions for handling conflicts\n3. Update the meal creation logic to assign targetEaters\n4. Ensure the UI can display multiple recipes per meal slot\n\nExample code for grouping eaters:\n```javascript\nfunction groupEatersByCompatibleProfiles(eaters) {\n  const groups = [];\n  const processed = new Set();\n  \n  for (let i = 0; i < eaters.length; i++) {\n    if (processed.has(i)) continue;\n    \n    const group = [eaters[i]];\n    processed.add(i);\n    \n    for (let j = i + 1; j < eaters.length; j++) {\n      if (processed.has(j)) continue;\n      \n      const conflict = hasProfileConflicts(\n        [eaters[i].dietProfile, eaters[j].dietProfile]\n      );\n      \n      if (!conflict.hasConflicts) {\n        group.push(eaters[j]);\n        processed.add(j);\n      }\n    }\n    \n    groups.push(group);\n  }\n  \n  return groups;\n}\n```",
        "testStrategy": "1. Unit test the eater grouping function with various combinations of diet profiles\n2. Test the meal generation with households having conflicting profiles\n3. Verify that separate recipes are generated for conflicting profiles\n4. Check that shopping lists include ingredients for all recipe variants\n5. Test edge cases like households with 3+ conflicting profiles\n6. Verify that flexible profiles (kid-friendly, flexitarian) are correctly added to all groups\n7. Test the needsMultiProfileGeneration() function with various household configurations",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Eater Grouping Utility",
            "description": "Implement utility functions for grouping eaters by diet compatibility and detecting conflicts.",
            "dependencies": [],
            "details": "Created eater grouping utility in src/utils/eaterGrouping.js with the following functions:\n- groupEatersByCompatibleProfiles() - Groups eaters by diet compatibility\n- needsMultiProfileGeneration() - Detects if household has conflicts\n- formatEaterNames() - Formats eater names for UI display\n- Added special handling for flexible profiles (kid-friendly, flexitarian) by adding them to all groups\n- Created test file at src/utils/__tests__/eaterGrouping.test.js",
            "status": "done",
            "testStrategy": "Unit test the eater grouping functions with various combinations of diet profiles, including edge cases with flexible profiles and multiple conflicting profiles.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Enhance Generation API",
            "description": "Update the meal generation API to handle multi-profile households and generate separate recipes when needed.",
            "dependencies": [
              1
            ],
            "details": "Enhanced the meal generation API in api/generate-meal-plan.js with:\n- Added checkDietProfileConflicts() function to detect Keto/Vegan/Vegetarian conflicts\n- Updated buildUserPrompt() to include multi-profile instructions when conflicts detected\n- Modified system prompt to support both single recipe and array-of-recipes format\n- Implemented logic to generate multiple recipes per meal with targetEaters and dietProfiles fields when conflicts exist",
            "status": "done",
            "testStrategy": "Test the API with various household configurations, including those with conflicting profiles. Verify that the system correctly detects conflicts and generates appropriate recipes.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Update Meal Plan Transformer",
            "description": "Modify the meal plan transformer to handle multiple recipes per meal slot and preserve target eater information.",
            "dependencies": [
              2
            ],
            "details": "Updated the meal plan transformer in src/utils/mealPlanTransformer.js to:\n- Modify extractRecipes() to handle array-of-recipes format for each meal slot\n- Update createMeals() to map targetEaters names to eater IDs\n- Generate separate Meal objects for each recipe in multi-profile scenarios\n- Preserve targetEaters and dietProfileTags fields in Meal schema",
            "status": "done",
            "testStrategy": "Test the transformer with various meal plan formats, including those with multiple recipes per meal slot. Verify that the correct Meal objects are created with appropriate targetEaters and dietProfileTags.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Verify Shopping List Integration",
            "description": "Confirm that the existing shopping list implementation works correctly with multi-profile meal plans.",
            "dependencies": [
              3
            ],
            "details": "Verified that the existing shopping list implementation works correctly with multi-profile meal plans:\n- Existing implementation already aggregates ingredients correctly\n- Sums all Meal servings for each recipe automatically\n- Works perfectly with multiple Meals per date+mealType\n- No changes needed to the shopping list component",
            "status": "done",
            "testStrategy": "Test the shopping list generation with multi-profile meal plans to ensure all ingredients are correctly aggregated.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Document Multi-Profile Implementation",
            "description": "Create documentation for the multi-profile meal generation implementation.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Document the complete multi-profile meal generation flow:\n1. User has household with conflicting profiles (e.g., Mom=Keto, Dad=Vegan)\n2. API detects conflict via checkDietProfileConflicts()\n3. Enhanced prompt instructs AI to generate array format with separate recipes\n4. Transformer creates separate Meal objects for same date+mealType\n5. Shopping list aggregates ingredients from both meals\n6. UI displays both recipes with eater labels",
            "status": "done",
            "testStrategy": "Review documentation for completeness and accuracy. Ensure all implementation details are correctly captured.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-10T05:01:33.040Z"
      },
      {
        "id": 102,
        "title": "Create Prep Task Generator",
        "description": "Develop a utility that analyzes recipes for a day and generates prep tasks based on prep level settings and batch opportunities.",
        "details": "Create src/utils/prepTaskGenerator.js with the following functionality:\n1. Analyze recipes for prep needs (chopping, marinating, etc.)\n2. Consider prep level settings (minimal/medium/full)\n3. Identify batch opportunities across meals\n4. Generate task list with time estimates\n\nThe generator should:\n- Extract prep steps from recipe instructions\n- Consolidate similar tasks (e.g., chopping multiple vegetables)\n- Assign estimated times based on task complexity\n- Tag tasks with timing (before_cooking, day_before, morning_of)\n- Identify which meals each prep task supports\n\nExample implementation:\n```javascript\nexport function generatePrepTasks(meals, prepLevels) {\n  const tasks = [];\n  const ingredientsByTask = {};\n  \n  // Extract potential prep tasks from each meal\n  meals.forEach(meal => {\n    const recipe = getRecipeById(meal.recipeId);\n    const prepLevel = getPrepLevelForMeal(meal, prepLevels);\n    \n    // Skip if prep level is minimal\n    if (prepLevel === 'minimal') return;\n    \n    // Extract prep tasks based on ingredients and instructions\n    const mealTasks = extractPrepTasksFromRecipe(recipe, prepLevel);\n    \n    // Add to consolidated tasks\n    mealTasks.forEach(task => {\n      const taskKey = task.type + ':' + task.ingredients.sort().join(',');\n      if (!ingredientsByTask[taskKey]) {\n        ingredientsByTask[taskKey] = {\n          task: task.description,\n          estimatedTime: task.estimatedTime,\n          timing: task.timing,\n          usedIn: [meal.mealType]\n        };\n      } else {\n        // Update existing task\n        if (!ingredientsByTask[taskKey].usedIn.includes(meal.mealType)) {\n          ingredientsByTask[taskKey].usedIn.push(meal.mealType);\n        }\n      }\n    });\n  });\n  \n  // Convert to array of tasks\n  return Object.values(ingredientsByTask);\n}\n```",
        "testStrategy": "1. Unit test with various recipes and prep levels\n2. Test batch identification with meals sharing ingredients\n3. Verify time estimates are reasonable for different tasks\n4. Test with edge cases (very simple recipes, complex recipes)\n5. Integration test with the DayView component",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 103,
        "title": "Implement DayView Prep Section",
        "description": "Enhance the DayView component to display a 'Prep for Today' section showing prep tasks, estimated times, and which meals each task supports.",
        "details": "Update the DayView component to:\n1. Display a 'Prep for Today' section at the top\n2. Show tasks, estimated times, and which meals each supports\n3. Calculate and display total prep time for the day\n\nThe implementation should:\n- Use the prepTaskGenerator utility to generate tasks\n- Group tasks by timing (morning_of, before_cooking)\n- Display estimated times and total time\n- Show which meals each task supports\n\nExample implementation:\n```jsx\nimport { generatePrepTasks } from '../utils/prepTaskGenerator';\n\nfunction DayView({ date, meals, prepLevels }) {\n  // Generate prep tasks for the day\n  const prepTasks = generatePrepTasks(meals, prepLevels);\n  const totalPrepTime = prepTasks.reduce((total, task) => total + task.estimatedTime, 0);\n  \n  return (\n    <div className=\"day-view\">\n      <h2>{formatDate(date)}</h2>\n      \n      {prepTasks.length > 0 && (\n        <div className=\"prep-section\">\n          <h3>ðŸ“‹ Prep for Today (~{totalPrepTime} minutes)</h3>\n          <ul className=\"prep-tasks\">\n            {prepTasks.map((task, index) => (\n              <li key={index}>\n                <span className=\"task-description\">{task.task}</span>\n                <span className=\"task-time\">({task.estimatedTime} min)</span>\n                <span className=\"task-meals\">â†’ for {task.usedIn.join(' & ')}</span>\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n      \n      {/* Existing meal sections */}\n      <div className=\"meals\">\n        {/* ... */}\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Unit test the component with various prep tasks\n2. Test rendering with different numbers of tasks\n3. Verify total time calculation\n4. Test with edge cases (no tasks, many tasks)\n5. Integration test with the meal plan view",
        "priority": "high",
        "dependencies": [
          "102"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 104,
        "title": "Implement Recipe Variation Creation Workflow",
        "description": "Create a workflow for users to create variations of existing recipes, maintaining parent-child relationships and recalculating health scores.",
        "details": "Implement a recipe variation system with:\n1. Enhanced recipe schema with parentRecipeId, childRecipeIds, and variationNote fields\n2. 'Create Variation' button on RecipeDetailPage\n3. RecipeEditPage workflow for variations\n4. Relationship display (parent shows children, child shows parent link)\n5. Diet Compass score recalculation for children\n\nImplementation steps:\n1. Update the recipe schema to include relationship fields\n2. Add a 'Create Variation' button to RecipeDetailPage\n3. Modify RecipeEditPage to handle variations\n4. Implement relationship display in RecipeDetailPage\n5. Ensure Diet Compass scores are recalculated for variations\n\nExample implementation:\n```jsx\n// RecipeDetailPage.jsx\nfunction RecipeDetailPage({ recipe }) {\n  const handleCreateVariation = () => {\n    // Create a copy of the recipe with parentRecipeId set\n    const variation = {\n      ...recipe,\n      recipeId: 'recipe_' + uuidv4(),\n      parentRecipeId: recipe.recipeId,\n      childRecipeIds: [],\n      variationNote: '',\n      name: `${recipe.name} (Variation)`,\n      isFavorite: false,\n      rating: null,\n      timesCooked: 0,\n      lastCooked: null,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n    \n    // Update parent recipe to include this child\n    const updatedParent = {\n      ...recipe,\n      childRecipeIds: [...(recipe.childRecipeIds || []), variation.recipeId]\n    };\n    \n    // Save both recipes\n    saveRecipe(updatedParent);\n    saveRecipe(variation);\n    \n    // Navigate to edit page for the variation\n    navigate(`/recipes/${variation.recipeId}/edit?isVariation=true`);\n  };\n  \n  return (\n    <div className=\"recipe-detail\">\n      {/* ... existing recipe detail content ... */}\n      \n      <button onClick={handleCreateVariation}>Create Variation</button>\n      \n      {/* Show parent recipe if this is a variation */}\n      {recipe.parentRecipeId && (\n        <div className=\"parent-recipe\">\n          <p>Variation of: <a href={`/recipes/${recipe.parentRecipeId}`}>\n            {getRecipeName(recipe.parentRecipeId)}\n          </a></p>\n        </div>\n      )}\n      \n      {/* Show child variations if any exist */}\n      {recipe.childRecipeIds && recipe.childRecipeIds.length > 0 && (\n        <div className=\"child-recipes\">\n          <h3>Variations:</h3>\n          <ul>\n            {recipe.childRecipeIds.map(childId => (\n              <li key={childId}>\n                <a href={`/recipes/${childId}`}>{getRecipeName(childId)}</a>\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Test creating variations of different recipe types (catalog, generated, user)\n2. Verify parent-child relationships are correctly maintained\n3. Test editing variations and ensuring parent recipe is unchanged\n4. Verify Diet Compass scores are recalculated correctly\n5. Test UI elements for displaying relationships",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 105,
        "title": "Implement Parent-Child Recipe Relationships",
        "description": "Enhance the recipe system to support parent-child relationships between original recipes and their variations.",
        "details": "Implement the backend functionality for parent-child recipe relationships:\n1. Update the recipe schema to include parentRecipeId, childRecipeIds, and variationNote fields\n2. Create utility functions for managing relationships\n3. Implement storage and retrieval of relationship data\n4. Ensure proper handling of relationship changes\n\nExample implementation:\n```javascript\n// src/utils/recipeRelationships.js\nexport function createVariation(parentRecipe) {\n  // Generate new ID for variation\n  const variationId = 'recipe_' + uuidv4();\n  \n  // Create variation with parent reference\n  const variation = {\n    ...parentRecipe,\n    recipeId: variationId,\n    parentRecipeId: parentRecipe.recipeId,\n    childRecipeIds: [],\n    variationNote: '',\n    name: `${parentRecipe.name} (Variation)`,\n    isFavorite: false,\n    rating: null,\n    timesCooked: 0,\n    lastCooked: null,\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString()\n  };\n  \n  // Update parent to include this child\n  const updatedParent = {\n    ...parentRecipe,\n    childRecipeIds: [...(parentRecipe.childRecipeIds || []), variationId]\n  };\n  \n  // Save both recipes\n  saveRecipe(updatedParent);\n  saveRecipe(variation);\n  \n  return variation;\n}\n\nexport function getRecipeWithRelationships(recipeId) {\n  const recipe = getRecipeById(recipeId);\n  \n  // Add parent recipe if exists\n  if (recipe.parentRecipeId) {\n    recipe.parentRecipe = getRecipeById(recipe.parentRecipeId);\n  }\n  \n  // Add child recipes if exist\n  if (recipe.childRecipeIds && recipe.childRecipeIds.length > 0) {\n    recipe.childRecipes = recipe.childRecipeIds.map(childId => \n      getRecipeById(childId)\n    ).filter(Boolean);\n  }\n  \n  return recipe;\n}\n```",
        "testStrategy": "1. Unit test relationship creation and management functions\n2. Test with various relationship scenarios (multiple levels of variations)\n3. Verify proper handling of deleted recipes in relationships\n4. Test storage and retrieval of relationship data\n5. Integration test with the recipe variation workflow",
        "priority": "medium",
        "dependencies": [
          "104"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 106,
        "title": "Implement AI Diet Profile Suggestion in Onboarding",
        "description": "Create a system to suggest appropriate diet profiles to users during onboarding based on their preferences and health goals.",
        "details": "Implement an AI-powered diet profile suggestion system:\n1. Create an onboarding questionnaire about dietary preferences and health goals\n2. Develop an AI prompt to analyze responses and suggest appropriate diet profiles\n3. Implement UI for displaying and selecting from suggested profiles\n4. Store selected profiles in the user's settings\n\nThe implementation should:\n- Ask about health goals, dietary restrictions, and food preferences\n- Use AI to analyze responses and match to appropriate diet profiles\n- Present suggestions with explanations of why they match\n- Allow users to select one or more profiles\n\nExample implementation:\n```javascript\n// src/utils/dietProfileSuggestion.js\nexport async function suggestDietProfiles(preferences) {\n  const { healthGoals, restrictions, preferences: foodPreferences } = preferences;\n  \n  // Prepare prompt for AI\n  const prompt = `\n    Based on the following user information, suggest the most appropriate diet profiles from our available options:\n    \n    Health Goals: ${healthGoals}\n    Dietary Restrictions: ${restrictions}\n    Food Preferences: ${foodPreferences}\n    \n    Available Profiles:\n    1. Mediterranean - Balanced, plant-forward, heart-healthy\n    2. Keto/Low-Carb - High fat, low carb for weight loss\n    3. Vegetarian - Plant-based with eggs/dairy\n    4. High Protein - Emphasis on protein for muscle building\n    5. Flexitarian - Mostly plant-based with occasional meat\n    6. Longevity Protocol - Focus on longevity and anti-aging\n    7. Intermittent Fasting - Timed eating patterns\n    8. Vegan - Strictly plant-based, no animal products\n    9. MIND - Brain health focus\n    10. Kid-Friendly - Balanced nutrition for children\n    11. La Dieta - Traditional Mediterranean approach\n    \n    For each suggested profile, explain why it matches their needs.\n  `;\n  \n  // Call AI API\n  const response = await callAI(prompt);\n  \n  // Parse response to extract suggestions\n  return parseSuggestions(response);\n}\n```\n<info added on 2026-01-10T05:25:38.082Z>\n## Child Age & Portion Multiplier Implementation\n\nAdd the following to the onboarding questionnaire:\n\n1. **Child Information Collection:**\n   - Include questions about children in the household\n   - Ask for each child's age\n   - Store this information during user profile creation\n\n2. **Portion Multiplier Assignment:**\n   - Implement automatic portion multiplier assignment based on age:\n     - 1-3 years (toddler): portionMultiplier = 0.25\n     - 4-8 years (young child): portionMultiplier = 0.5\n     - 9-13 years (older child): portionMultiplier = 0.75\n     - 14-18 years (teen): portionMultiplier = 0.9\n     - 18+ years (adult): portionMultiplier = 1.0\n\n3. **AI Conversation Extraction:**\n   - Enhance the AI prompt to extract child information from natural conversation\n   - Implement logic to detect age mentions and automatically assign appropriate multipliers\n   - Support multiple children with different ages\n\n4. **Eater Object Creation:**\n   - When creating eater objects, include the portionMultiplier field\n   - Store this value alongside other eater information (name, dietProfile, etc.)\n   - Use this multiplier for accurate meal planning and shopping list generation\n\n5. **Example Implementation:**\n```javascript\n// src/utils/portionMultiplierCalculator.js\nexport function calculatePortionMultiplier(age) {\n  if (age < 4) return 0.25;\n  if (age < 9) return 0.5;\n  if (age < 14) return 0.75;\n  if (age < 19) return 0.9;\n  return 1.0;\n}\n\n// Extract from conversation in AI prompt\nconst childAgePattern = /(\\d+)[\\s-]*(year|yr)s?[\\s-]*(old)?/i;\nif (childAgePattern.test(userMessage)) {\n  const age = parseInt(userMessage.match(childAgePattern)[1]);\n  const multiplier = calculatePortionMultiplier(age);\n  // Add to eater object\n  eater.portionMultiplier = multiplier;\n}\n```\n</info added on 2026-01-10T05:25:38.082Z>",
        "testStrategy": "1. Test with various user preferences and goals\n2. Verify suggestions match expected profiles for common scenarios\n3. Test edge cases (conflicting preferences, unusual goals)\n4. Verify UI correctly displays suggestions and handles selection\n5. Test integration with the onboarding flow",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 107,
        "title": "Implement Server-Side Health Scoring API",
        "description": "Create a server-side API for calculating Diet Compass health scores to improve performance and consistency.",
        "details": "Implement a server-side health scoring API:\n1. Port the dietCompassScoring.js utility to server-side\n2. Create an API endpoint for calculating scores\n3. Implement batch scoring for multiple recipes\n4. Ensure consistent scoring between client and server\n\nThe implementation should:\n- Accept recipe data in the request body\n- Calculate all 4 metric scores + overall score\n- Return detailed scoring breakdown\n- Support batch processing for efficiency\n\nExample implementation:\n```javascript\n// server/api/healthScoring.js\nconst { calculateRecipeScores } = require('../utils/dietCompassScoring');\n\nmodule.exports = function(app) {\n  app.post('/api/health-scores', (req, res) => {\n    const { recipes } = req.body;\n    \n    if (!recipes || !Array.isArray(recipes)) {\n      return res.status(400).json({ error: 'Invalid request. Expected array of recipes.' });\n    }\n    \n    try {\n      const results = recipes.map(recipe => ({\n        recipeId: recipe.recipeId,\n        scores: calculateRecipeScores(recipe)\n      }));\n      \n      return res.json({ results });\n    } catch (error) {\n      console.error('Error calculating health scores:', error);\n      return res.status(500).json({ error: 'Failed to calculate health scores' });\n    }\n  });\n  \n  app.post('/api/health-score', (req, res) => {\n    const { recipe } = req.body;\n    \n    if (!recipe) {\n      return res.status(400).json({ error: 'Invalid request. Expected recipe object.' });\n    }\n    \n    try {\n      const scores = calculateRecipeScores(recipe);\n      return res.json({ scores });\n    } catch (error) {\n      console.error('Error calculating health score:', error);\n      return res.status(500).json({ error: 'Failed to calculate health score' });\n    }\n  });\n};\n```",
        "testStrategy": "1. Unit test the API endpoints with various recipes\n2. Test batch processing with multiple recipes\n3. Verify scores match client-side calculations\n4. Test error handling with invalid inputs\n5. Performance test with large batches of recipes",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 108,
        "title": "Create Unit Tests for Utilities",
        "description": "Develop comprehensive unit tests for the utility functions to ensure reliability and catch regressions.",
        "details": "Create unit tests for key utility functions:\n1. dietCompassScoring.js - Test score calculations\n2. dietProfileFilter.js - Test profile filtering and conflict detection\n3. prepTaskGenerator.js - Test prep task generation\n4. ingredientMaster.js - Test ingredient normalization\n5. ingredientParsing.js - Test ingredient parsing\n\nUse Jest for testing and aim for high coverage of edge cases.\n\nExample implementation:\n```javascript\n// tests/utils/dietCompassScoring.test.js\nimport { calculateRecipeScores, getIngredientHealthData, scoreToBarSegments } from '../../src/utils/dietCompassScoring';\n\ndescribe('Diet Compass Scoring', () => {\n  describe('calculateRecipeScores', () => {\n    test('should calculate correct scores for a healthy recipe', () => {\n      const recipe = {\n        ingredients: [\n          { name: 'salmon', quantity: 200, unit: 'g' },\n          { name: 'olive oil', quantity: 15, unit: 'ml' },\n          { name: 'spinach', quantity: 100, unit: 'g' },\n          { name: 'lemon', quantity: 1, unit: '' }\n        ]\n      };\n      \n      const scores = calculateRecipeScores(recipe);\n      \n      expect(scores.overall).toBeGreaterThan(70);\n      expect(scores.nutrientDensity).toBeGreaterThan(70);\n      expect(scores.antiAging).toBeGreaterThan(70);\n      expect(scores.weightLoss).toBeGreaterThan(60);\n      expect(scores.heartHealth).toBeGreaterThan(70);\n    });\n    \n    test('should calculate correct scores for an unhealthy recipe', () => {\n      const recipe = {\n        ingredients: [\n          { name: 'bacon', quantity: 100, unit: 'g' },\n          { name: 'white bread', quantity: 2, unit: 'slices' },\n          { name: 'mayonnaise', quantity: 30, unit: 'g' },\n          { name: 'processed cheese', quantity: 50, unit: 'g' }\n        ]\n      };\n      \n      const scores = calculateRecipeScores(recipe);\n      \n      expect(scores.overall).toBeLessThan(40);\n      expect(scores.heartHealth).toBeLessThan(30);\n    });\n  });\n  \n  // More tests...\n});\n```",
        "testStrategy": "1. Test each utility function with normal inputs\n2. Test edge cases and boundary conditions\n3. Test error handling and invalid inputs\n4. Verify results match expected outputs\n5. Aim for at least 80% code coverage",
        "priority": "medium",
        "dependencies": [
          "100",
          "102"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 109,
        "title": "Create Admin Catalog Management UI",
        "description": "Develop an admin interface for managing the recipe catalog, including adding, editing, and removing recipes.",
        "details": "Create an admin catalog management UI with the following features:\n1. View all catalog recipes with filtering and sorting\n2. Add new recipes to the catalog\n3. Edit existing catalog recipes\n4. Remove recipes from the catalog\n5. Batch operations (tag multiple recipes, delete multiple)\n\nThe implementation should:\n- Create an AdminCatalogPage component\n- Implement a data table for viewing recipes\n- Create forms for adding and editing recipes\n- Implement batch operations functionality\n- Add authentication to restrict access\n\nExample implementation:\n```jsx\n// src/pages/AdminCatalogPage.jsx\nimport React, { useState, useEffect } from 'react';\nimport { Table, Button, Modal, Form, Input, Select, Tag } from 'antd';\nimport { getRecipeCatalog, saveRecipeToCatalog, removeRecipeFromCatalog } from '../utils/catalogManager';\n\nfunction AdminCatalogPage() {\n  const [catalog, setCatalog] = useState([]);\n  const [loading, setLoading] = useState(true);\n  const [editModalVisible, setEditModalVisible] = useState(false);\n  const [currentRecipe, setCurrentRecipe] = useState(null);\n  const [selectedRowKeys, setSelectedRowKeys] = useState([]);\n  \n  useEffect(() => {\n    loadCatalog();\n  }, []);\n  \n  const loadCatalog = async () => {\n    setLoading(true);\n    const recipes = await getRecipeCatalog();\n    setCatalog(recipes);\n    setLoading(false);\n  };\n  \n  const handleEdit = (recipe) => {\n    setCurrentRecipe(recipe);\n    setEditModalVisible(true);\n  };\n  \n  const handleSave = async (values) => {\n    const updatedRecipe = { ...currentRecipe, ...values };\n    await saveRecipeToCatalog(updatedRecipe);\n    setEditModalVisible(false);\n    loadCatalog();\n  };\n  \n  const handleDelete = async (recipeId) => {\n    await removeRecipeFromCatalog(recipeId);\n    loadCatalog();\n  };\n  \n  const handleBatchDelete = async () => {\n    for (const recipeId of selectedRowKeys) {\n      await removeRecipeFromCatalog(recipeId);\n    }\n    setSelectedRowKeys([]);\n    loadCatalog();\n  };\n  \n  const columns = [\n    {\n      title: 'Name',\n      dataIndex: 'name',\n      sorter: (a, b) => a.name.localeCompare(b.name),\n    },\n    {\n      title: 'Source',\n      dataIndex: 'source',\n      filters: [\n        { text: 'Spoonacular', value: 'spoonacular' },\n        { text: 'Generated', value: 'generated' },\n        { text: 'User', value: 'user' },\n        { text: 'Imported', value: 'imported' },\n      ],\n      onFilter: (value, record) => record.source === value,\n    },\n    {\n      title: 'Diet Profiles',\n      dataIndex: 'tags',\n      render: (tags) => (\n        <>\n          {tags.diets.map(diet => (\n            <Tag key={diet}>{diet}</Tag>\n          ))}\n        </>\n      ),\n    },\n    {\n      title: 'Health Score',\n      dataIndex: 'dietCompassScores',\n      render: (scores) => scores.overall,\n      sorter: (a, b) => a.dietCompassScores.overall - b.dietCompassScores.overall,\n    },\n    {\n      title: 'Actions',\n      render: (_, record) => (\n        <>\n          <Button onClick={() => handleEdit(record)}>Edit</Button>\n          <Button danger onClick={() => handleDelete(record.recipeId)}>Delete</Button>\n        </>\n      ),\n    },\n  ];\n  \n  return (\n    <div className=\"admin-catalog\">\n      <h1>Catalog Management</h1>\n      \n      <div className=\"actions\">\n        <Button type=\"primary\" onClick={() => handleEdit(null)}>Add Recipe</Button>\n        {selectedRowKeys.length > 0 && (\n          <Button danger onClick={handleBatchDelete}>\n            Delete Selected ({selectedRowKeys.length})\n          </Button>\n        )}\n      </div>\n      \n      <Table\n        rowSelection={{\n          selectedRowKeys,\n          onChange: setSelectedRowKeys,\n        }}\n        columns={columns}\n        dataSource={catalog}\n        rowKey=\"recipeId\"\n        loading={loading}\n      />\n      \n      <Modal\n        title={currentRecipe ? 'Edit Recipe' : 'Add Recipe'}\n        visible={editModalVisible}\n        onCancel={() => setEditModalVisible(false)}\n        footer={null}\n      >\n        <Form\n          initialValues={currentRecipe || {}}\n          onFinish={handleSave}\n          layout=\"vertical\"\n        >\n          {/* Form fields */}\n        </Form>\n      </Modal>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Test UI rendering with various catalog sizes\n2. Test adding, editing, and deleting recipes\n3. Test batch operations\n4. Verify filtering and sorting functionality\n5. Test authentication and access control",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 110,
        "title": "Enhance Generation Prompts for Multi-Profile Support",
        "description": "Update the AI system prompts to better handle multi-profile households and diet conflicts.",
        "details": "Enhance the AI system prompts for meal generation:\n1. Update the prompt to include instructions for handling diet profile conflicts\n2. Add guidance for generating multiple recipes when needed\n3. Include instructions for labeling recipes with target eaters\n4. Add examples of handling common conflict scenarios\n\nThe implementation should:\n- Modify the API request handler to include enhanced prompts\n- Update the prompt template to include multi-profile instructions\n- Add examples of handling Keto + Vegan and other common conflicts\n- Include guidance for maintaining nutritional balance\n\nExample implementation:\n```javascript\nfunction buildMultiProfilePrompt(eaters, baseSpecification) {\n  // Group eaters by diet profile\n  const profileGroups = {};\n  eaters.forEach(eater => {\n    if (!profileGroups[eater.dietProfile]) {\n      profileGroups[eater.dietProfile] = [];\n    }\n    profileGroups[eater.dietProfile].push(eater.name);\n  });\n  \n  // Check for conflicts\n  const conflicts = hasProfileConflicts(Object.keys(profileGroups));\n  \n  let prompt = `\n    You are Vanessa, an expert meal planning assistant.\n    \n    HOUSEHOLD MEMBERS & DIET PROFILES:\n  `;\n  \n  // Add eater profiles\n  eaters.forEach(eater => {\n    prompt += `\n    - ${eater.name}: ${eater.dietProfile} diet\n      Exclude: ${eater.excludeIngredients.join(', ')}\n      Prefer: ${eater.personalPreferences}\n    `;\n  });\n  \n  prompt += `\n    MEAL PREP CONSTRAINTS:\n  `;\n  \n  // Add prep constraints\n  Object.entries(baseSpecification.mealPrepSettings.prepLevels).forEach(([day, meals]) => {\n    Object.entries(meals).forEach(([meal, level]) => {\n      prompt += `\n    - ${day} ${meal}: ${level} prep\n      `;\n    });\n  });\n  \n  prompt += `\n    RECIPE SOURCES:\n    - PRIMARILY use recipes from catalog\n    - CREATE new recipe ONLY if no catalog match or conflicts\n  `;\n  \n  // Add multi-profile instructions if conflicts exist\n  if (conflicts.hasConflicts) {\n    prompt += `\n    DIET PROFILE CONFLICTS:\n    The following profiles conflict and require separate recipes:\n    ${conflicts.conflictPairs.map(pair => `- ${pair[0]} and ${pair[1]}`).join('\\n')}\n    \n    INSTRUCTIONS FOR CONFLICTS:\n    - Generate SEPARATE recipes for conflicting profiles\n    - Label each recipe with target eaters\n    - Ensure nutritional balance for each profile\n    - Consider shared ingredients where possible to minimize shopping list\n    \n    EXAMPLE:\n    Tuesday Dinner (Keto + Vegan conflict):\n    - Recipe 1: Salmon with Asparagus (Keto) â†’ for [names of keto eaters]\n    - Recipe 2: Tofu Buddha Bowl (Vegan) â†’ for [names of vegan eaters]\n    `;\n  }\n  \n  return prompt;\n}\n```",
        "testStrategy": "1. Test prompt generation with various household configurations\n2. Verify conflict detection and handling in prompts\n3. Test with common conflict scenarios (Keto + Vegan, etc.)\n4. Verify AI responses follow the enhanced instructions\n5. Test integration with the meal generation flow",
        "priority": "medium",
        "dependencies": [
          "100",
          "101"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 111,
        "title": "Implement Health Data Persistence to localStorage",
        "description": "Enhance the system to persist health data to localStorage for improved performance and offline access.",
        "details": "Implement health data persistence to localStorage:\n1. Create a utility for saving and loading health data\n2. Implement caching of Diet Compass scores\n3. Add versioning for health data to handle updates\n4. Implement automatic updates when ingredient health data changes\n\nThe implementation should:\n- Store ingredient health data in localStorage\n- Cache calculated recipe scores\n- Handle version changes gracefully\n- Provide fallback for missing data\n\nExample implementation:\n```javascript\n// src/utils/healthDataPersistence.js\nconst HEALTH_DATA_KEY = 'vanessa_ingredient_health';\nconst HEALTH_SCORES_KEY = 'vanessa_recipe_health_scores';\nconst HEALTH_DATA_VERSION_KEY = 'vanessa_health_data_version';\nconst CURRENT_VERSION = '1.0';\n\nexport function saveIngredientHealthData(data) {\n  try {\n    localStorage.setItem(HEALTH_DATA_KEY, JSON.stringify(data));\n    localStorage.setItem(HEALTH_DATA_VERSION_KEY, CURRENT_VERSION);\n    return true;\n  } catch (error) {\n    console.error('Failed to save ingredient health data:', error);\n    return false;\n  }\n}\n\nexport function getIngredientHealthData() {\n  try {\n    const data = localStorage.getItem(HEALTH_DATA_KEY);\n    const version = localStorage.getItem(HEALTH_DATA_VERSION_KEY);\n    \n    if (!data) return null;\n    \n    // Check version\n    if (version !== CURRENT_VERSION) {\n      console.warn('Health data version mismatch. Clearing cache.');\n      clearHealthDataCache();\n      return null;\n    }\n    \n    return JSON.parse(data);\n  } catch (error) {\n    console.error('Failed to load ingredient health data:', error);\n    return null;\n  }\n}\n\nexport function saveRecipeHealthScores(recipeId, scores) {\n  try {\n    let allScores = getRecipeHealthScores() || {};\n    allScores[recipeId] = {\n      scores,\n      timestamp: Date.now()\n    };\n    \n    localStorage.setItem(HEALTH_SCORES_KEY, JSON.stringify(allScores));\n    return true;\n  } catch (error) {\n    console.error('Failed to save recipe health scores:', error);\n    return false;\n  }\n}\n\nexport function getRecipeHealthScores(recipeId) {\n  try {\n    const allScores = localStorage.getItem(HEALTH_SCORES_KEY);\n    if (!allScores) return recipeId ? null : {};\n    \n    const parsed = JSON.parse(allScores);\n    return recipeId ? parsed[recipeId] : parsed;\n  } catch (error) {\n    console.error('Failed to load recipe health scores:', error);\n    return recipeId ? null : {};\n  }\n}\n\nexport function clearHealthDataCache() {\n  localStorage.removeItem(HEALTH_SCORES_KEY);\n  localStorage.removeItem(HEALTH_DATA_KEY);\n  localStorage.removeItem(HEALTH_DATA_VERSION_KEY);\n}\n```",
        "testStrategy": "1. Test saving and loading health data\n2. Test version checking and cache clearing\n3. Test recipe score caching and retrieval\n4. Test error handling with invalid data\n5. Test performance with large datasets",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 112,
        "title": "Implement Data Migration for Slice 5 Schema",
        "description": "Create a migration utility to update existing data to the new Slice 5 schema.",
        "details": "Implement a data migration utility for Slice 5:\n1. Create a migration script to update existing data\n2. Handle schema changes for recipes, meals, and base specification\n3. Add version checking to detect and migrate old data\n4. Implement rollback functionality for failed migrations\n\nThe implementation should:\n- Check schema version on app startup\n- Migrate data if needed\n- Back up old data before migration\n- Handle errors gracefully\n\nExample implementation:\n```javascript\n// src/migrations/migrateToSlice5.js\nexport async function migrateToSlice5() {\n  try {\n    // Check current schema version\n    const baseSpec = JSON.parse(localStorage.getItem('vanessa_base_specification') || '{}');\n    const currentVersion = baseSpec._schemaVersion || 1;\n    \n    if (currentVersion >= 2) {\n      console.log('Already on Slice 5 schema (version 2). No migration needed.');\n      return { success: true, message: 'No migration needed' };\n    }\n    \n    console.log('Migrating from schema version', currentVersion, 'to version 2');\n    \n    // Backup old data\n    backupData();\n    \n    // Migrate base specification\n    await migrateBaseSpecification();\n    \n    // Migrate recipes\n    await migrateRecipes();\n    \n    // Migrate meals\n    await migrateMeals();\n    \n    console.log('Migration to Slice 5 schema complete');\n    return { success: true, message: 'Migration completed successfully' };\n  } catch (error) {\n    console.error('Migration failed:', error);\n    return { success: false, message: error.message };\n  }\n}\n\nfunction backupData() {\n  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n  const keys = [\n    'vanessa_base_specification',\n    'vanessa_recipes',\n    'vanessa_meals',\n    'vanessa_current_meal_plan',\n    'vanessa_meal_plan_history'\n  ];\n  \n  keys.forEach(key => {\n    const data = localStorage.getItem(key);\n    if (data) {\n      localStorage.setItem(`${key}_backup_${timestamp}`, data);\n    }\n  });\n  \n  console.log('Data backup created with timestamp:', timestamp);\n}\n\nasync function migrateBaseSpecification() {\n  const baseSpecStr = localStorage.getItem('vanessa_base_specification');\n  if (!baseSpecStr) return;\n  \n  const baseSpec = JSON.parse(baseSpecStr);\n  \n  // Add new fields for Slice 5\n  const updatedBaseSpec = {\n    ...baseSpec,\n    _schemaVersion: 2,\n    mealPrepSettings: baseSpec.mealPrepSettings || {\n      batchPrepDays: [6],  // Saturday\n      prepLevels: {\n        monday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'medium' },\n        tuesday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'medium' },\n        wednesday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'medium' },\n        thursday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'medium' },\n        friday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'medium' },\n        saturday: { breakfast: 'medium', lunch: 'medium', dinner: 'medium' },\n        sunday: { breakfast: 'medium', lunch: 'medium', dinner: 'medium' }\n      }\n    }\n  };\n  \n  localStorage.setItem('vanessa_base_specification', JSON.stringify(updatedBaseSpec));\n}\n\nasync function migrateRecipes() {\n  const recipesStr = localStorage.getItem('vanessa_recipes');\n  if (!recipesStr) return;\n  \n  const recipes = JSON.parse(recipesStr);\n  \n  const updatedRecipes = recipes.map(recipe => ({\n    ...recipe,\n    parentRecipeId: null,\n    childRecipeIds: [],\n    variationNote: null,\n    dietCompassScores: recipe.dietCompassScores || {\n      overall: 50,\n      nutrientDensity: 50,\n      antiAging: 50,\n      weightLoss: 50,\n      heartHealth: 50\n    },\n    tags: recipe.tags || {\n      cuisines: [],\n      diets: [],\n      dishTypes: [],\n      mealSlots: [],\n      proteinSources: [],\n      cookingMethods: [],\n      carbBases: [],\n      effortLevel: 'medium',\n      spiceLevel: 'medium',\n      budgetTier: 'moderate',\n      kidFriendly: false,\n      makeAhead: false,\n      protectiveFoods: []\n    }\n  }));\n  \n  localStorage.setItem('vanessa_recipes', JSON.stringify(updatedRecipes));\n}\n\nasync function migrateMeals() {\n  const mealsStr = localStorage.getItem('vanessa_meals');\n  if (!mealsStr) return;\n  \n  const meals = JSON.parse(mealsStr);\n  \n  const updatedMeals = meals.map(meal => ({\n    ...meal,\n    prepTasks: [],\n    targetEaters: meal.eaterIds || [],\n    dietProfileTags: []\n  }));\n  \n  localStorage.setItem('vanessa_meals', JSON.stringify(updatedMeals));\n}\n```",
        "testStrategy": "1. Test migration with various initial states\n2. Verify data integrity after migration\n3. Test rollback functionality\n4. Test error handling during migration\n5. Test with edge cases (missing data, corrupted data)",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 113,
        "title": "Implement Ingredient Normalization Enhancement",
        "description": "Improve the ingredient normalization pipeline to achieve a 95%+ match rate with an expanded dictionary.",
        "details": "Enhance the ingredient normalization pipeline:\n1. Expand the ingredient dictionary to 1000+ entries\n2. Improve fuzzy matching algorithm\n3. Add handling for compound ingredients\n4. Implement state tracking (fresh vs canned)\n\nThe implementation should:\n- Update the ingredient dictionary with more entries\n- Enhance the matching algorithm for better accuracy\n- Add special handling for compound ingredients\n- Track ingredient state (fresh, frozen, canned, etc.)\n\nExample implementation:\n```javascript\n// src/pipelines/normalizeRecipeIngredients.js\nimport { levenshteinDistance } from '../utils/stringUtils';\nimport ingredientDictionary from '../data/ingredientDictionary.json';\n\nexport function normalizeIngredient(ingredientName) {\n  // Clean up the ingredient name\n  const cleaned = cleanIngredientName(ingredientName);\n  \n  // Check for compound ingredients\n  const compounds = splitCompoundIngredient(cleaned);\n  if (compounds.length > 1) {\n    return compounds.map(c => normalizeIngredient(c));\n  }\n  \n  // Extract state if present\n  const { name, state } = extractIngredientState(cleaned);\n  \n  // Try exact match first\n  const exactMatch = ingredientDictionary.find(i => \n    i.name.toLowerCase() === name.toLowerCase() ||\n    i.aliases.some(a => a.toLowerCase() === name.toLowerCase())\n  );\n  \n  if (exactMatch) {\n    return { ...exactMatch, state };\n  }\n  \n  // Try fuzzy matching\n  const matches = ingredientDictionary.map(ingredient => {\n    const nameDistance = levenshteinDistance(name.toLowerCase(), ingredient.name.toLowerCase());\n    const aliasDistances = ingredient.aliases.map(alias => \n      levenshteinDistance(name.toLowerCase(), alias.toLowerCase())\n    );\n    const minAliasDistance = aliasDistances.length > 0 ? Math.min(...aliasDistances) : Infinity;\n    const distance = Math.min(nameDistance, minAliasDistance);\n    \n    return { ingredient, distance };\n  });\n  \n  // Sort by distance and get the best match\n  matches.sort((a, b) => a.distance - b.distance);\n  \n  // If the best match is close enough, use it\n  if (matches[0].distance <= 2 || matches[0].distance / name.length < 0.3) {\n    return { ...matches[0].ingredient, state };\n  }\n  \n  // No good match found, return the original with a flag\n  return {\n    name,\n    state,\n    category: 'unknown',\n    normalized: false\n  };\n}\n\nfunction cleanIngredientName(name) {\n  // Remove quantities, units, and common prefixes\n  return name\n    .replace(/^\\d+(\\/\\d+)?\\s*(cup|tablespoon|teaspoon|tbsp|tsp|oz|ounce|pound|lb|g|gram|ml|liter|l)s?\\s+of\\s+/i, '')\n    .replace(/^\\d+(\\/\\d+)?\\s*(cup|tablespoon|teaspoon|tbsp|tsp|oz|ounce|pound|lb|g|gram|ml|liter|l)s?\\s+/i, '')\n    .replace(/^(a few|a handful of|some|a little|a lot of)\\s+/i, '')\n    .replace(/^(fresh|dried|ground|minced|chopped|diced|sliced|grated|shredded)\\s+/i, '')\n    .trim();\n}\n\nfunction splitCompoundIngredient(name) {\n  // Split on 'and' or commas, but handle special cases\n  if (name.includes(' and ') && !name.match(/salt and pepper|oil and vinegar|mac and cheese|peanut butter and jelly/i)) {\n    return name.split(' and ').map(part => part.trim());\n  }\n  \n  if (name.includes(',') && !name.match(/salt, to taste|pepper, to taste/i)) {\n    return name.split(',').map(part => part.trim()).filter(Boolean);\n  }\n  \n  return [name];\n}\n\nfunction extractIngredientState(name) {\n  const statePatterns = [\n    { regex: /(fresh|raw)\\s+(.+)/i, state: 'fresh' },\n    { regex: /(frozen|thawed)\\s+(.+)/i, state: 'frozen' },\n    { regex: /(canned|tinned)\\s+(.+)/i, state: 'canned' },\n    { regex: /(dried|dehydrated)\\s+(.+)/i, state: 'dried' },\n    { regex: /(cooked|boiled|steamed|roasted)\\s+(.+)/i, state: 'cooked' }\n  ];\n  \n  for (const pattern of statePatterns) {\n    const match = name.match(pattern.regex);\n    if (match) {\n      return { name: match[2], state: pattern.state };\n    }\n  }\n  \n  return { name, state: 'unspecified' };\n}\n```",
        "testStrategy": "1. Test with a variety of ingredient names\n2. Verify match rate on a test dataset of 1000+ ingredients\n3. Test compound ingredient splitting\n4. Test state extraction\n5. Benchmark performance with large recipe sets",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 114,
        "title": "Implement Enhanced Shopping List Consolidation",
        "description": "Improve the shopping list consolidation to handle multi-profile households with multiple recipes per meal.",
        "details": "Enhance the shopping list consolidation:\n1. Handle multiple recipes per meal for multi-profile households\n2. Group ingredients by store section\n3. Consolidate similar ingredients with different states\n4. Add recipe references to each ingredient\n\nThe implementation should:\n- Consolidate ingredients across all recipes\n- Handle unit conversions (e.g., 2 tbsp + 1 tsp = 7 tsp)\n- Group by store section for easier shopping\n- Show which recipes each ingredient is used in\n\nExample implementation:\n```javascript\n// src/utils/shoppingListConsolidation.js\nimport { normalizeIngredient } from '../pipelines/normalizeRecipeIngredients';\nimport { convertUnits } from './unitConversion';\n\nexport function consolidateShoppingList(meals) {\n  // Extract all ingredients from all recipes\n  const allIngredients = [];\n  \n  meals.forEach(meal => {\n    const recipe = getRecipeById(meal.recipeId);\n    if (!recipe) return;\n    \n    recipe.ingredients.forEach(ingredient => {\n      // Normalize the ingredient\n      const normalized = normalizeIngredient(ingredient.name);\n      \n      // Add to the list with recipe reference\n      allIngredients.push({\n        ...ingredient,\n        normalizedName: normalized.name,\n        category: normalized.category || ingredient.category || 'other',\n        state: normalized.state || 'unspecified',\n        recipeId: recipe.recipeId,\n        recipeName: recipe.name,\n        mealId: meal.mealId,\n        mealType: meal.mealType,\n        date: meal.date\n      });\n    });\n  });\n  \n  // Group by normalized name and consolidate\n  const consolidatedMap = {};\n  \n  allIngredients.forEach(ingredient => {\n    const key = `${ingredient.normalizedName}:${ingredient.state}`;\n    \n    if (!consolidatedMap[key]) {\n      consolidatedMap[key] = {\n        name: ingredient.name,\n        normalizedName: ingredient.normalizedName,\n        quantity: ingredient.quantity,\n        unit: ingredient.unit,\n        category: ingredient.category,\n        state: ingredient.state,\n        recipes: [{\n          recipeId: ingredient.recipeId,\n          recipeName: ingredient.recipeName,\n          mealId: ingredient.mealId,\n          mealType: ingredient.mealType,\n          date: ingredient.date\n        }]\n      };\n    } else {\n      // Add recipe reference\n      consolidatedMap[key].recipes.push({\n        recipeId: ingredient.recipeId,\n        recipeName: ingredient.recipeName,\n        mealId: ingredient.mealId,\n        mealType: ingredient.mealType,\n        date: ingredient.date\n      });\n      \n      // Try to consolidate quantities\n      if (ingredient.unit === consolidatedMap[key].unit) {\n        consolidatedMap[key].quantity += ingredient.quantity;\n      } else {\n        // Try to convert units\n        const converted = convertUnits(ingredient.quantity, ingredient.unit, consolidatedMap[key].unit);\n        if (converted) {\n          consolidatedMap[key].quantity += converted;\n        } else {\n          // Can't convert, keep separate\n          const newKey = `${key}:${ingredient.unit}:${Date.now()}`;\n          consolidatedMap[newKey] = {\n            name: ingredient.name,\n            normalizedName: ingredient.normalizedName,\n            quantity: ingredient.quantity,\n            unit: ingredient.unit,\n            category: ingredient.category,\n            state: ingredient.state,\n            recipes: [{\n              recipeId: ingredient.recipeId,\n              recipeName: ingredient.recipeName,\n              mealId: ingredient.mealId,\n              mealType: ingredient.mealType,\n              date: ingredient.date\n            }]\n          };\n        }\n      }\n    }\n  });\n  \n  // Convert to array and group by category\n  const consolidated = Object.values(consolidatedMap);\n  const groupedByCategory = {};\n  \n  consolidated.forEach(item => {\n    if (!groupedByCategory[item.category]) {\n      groupedByCategory[item.category] = [];\n    }\n    groupedByCategory[item.category].push(item);\n  });\n  \n  return {\n    consolidated,\n    groupedByCategory\n  };\n}\n```",
        "testStrategy": "1. Test with various meal plans including multi-profile households\n2. Verify ingredient consolidation across recipes\n3. Test unit conversions\n4. Verify recipe references are correctly maintained\n5. Test with edge cases (missing data, unusual units)",
        "priority": "high",
        "dependencies": [
          "101",
          "113"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 115,
        "title": "Implement Recipe Search and Filtering",
        "description": "Create a comprehensive search and filtering system for the recipe catalog.",
        "details": "Implement recipe search and filtering:\n1. Create a search utility for finding recipes by name, ingredients, or tags\n2. Implement filtering by diet profile, cuisine, effort level, etc.\n3. Add sorting options (health score, prep time, etc.)\n4. Create a UI for the search and filter functionality\n\nThe implementation should:\n- Support text search across recipe fields\n- Allow filtering by multiple criteria\n- Provide sorting options\n- Include a user-friendly UI\n\nExample implementation:\n```javascript\n// src/utils/recipeSearch.js\nexport function searchRecipes(catalog, options) {\n  const {\n    query,\n    dietProfiles,\n    cuisines,\n    effortLevels,\n    mealTypes,\n    includeIngredients,\n    excludeIngredients,\n    minHealthScore,\n    maxPrepTime,\n    sortBy,\n    sortDirection\n  } = options;\n  \n  // Filter recipes\n  let results = catalog;\n  \n  // Text search\n  if (query) {\n    const lowerQuery = query.toLowerCase();\n    results = results.filter(recipe => {\n      // Search in name\n      if (recipe.name.toLowerCase().includes(lowerQuery)) return true;\n      \n      // Search in ingredients\n      if (recipe.ingredients.some(i => i.name.toLowerCase().includes(lowerQuery))) return true;\n      \n      // Search in tags\n      const allTags = [\n        ...(recipe.tags.cuisines || []),\n        ...(recipe.tags.diets || []),\n        ...(recipe.tags.dishTypes || []),\n        ...(recipe.tags.proteinSources || []),\n        ...(recipe.tags.cookingMethods || []),\n        ...(recipe.tags.carbBases || [])\n      ];\n      if (allTags.some(tag => tag.toLowerCase().includes(lowerQuery))) return true;\n      \n      return false;\n    });\n  }\n  \n  // Filter by diet profiles\n  if (dietProfiles && dietProfiles.length > 0) {\n    results = results.filter(recipe => \n      dietProfiles.some(profile => recipe.tags.diets.includes(profile))\n    );\n  }\n  \n  // Filter by cuisines\n  if (cuisines && cuisines.length > 0) {\n    results = results.filter(recipe => \n      cuisines.some(cuisine => recipe.tags.cuisines.includes(cuisine))\n    );\n  }\n  \n  // Filter by effort levels\n  if (effortLevels && effortLevels.length > 0) {\n    results = results.filter(recipe => \n      effortLevels.includes(recipe.tags.effortLevel)\n    );\n  }\n  \n  // Filter by meal types\n  if (mealTypes && mealTypes.length > 0) {\n    results = results.filter(recipe => \n      mealTypes.some(type => recipe.tags.mealSlots.includes(type))\n    );\n  }\n  \n  // Filter by included ingredients\n  if (includeIngredients && includeIngredients.length > 0) {\n    results = results.filter(recipe => \n      includeIngredients.every(ingredient => \n        recipe.ingredients.some(i => \n          i.name.toLowerCase().includes(ingredient.toLowerCase())\n        )\n      )\n    );\n  }\n  \n  // Filter by excluded ingredients\n  if (excludeIngredients && excludeIngredients.length > 0) {\n    results = results.filter(recipe => \n      !excludeIngredients.some(ingredient => \n        recipe.ingredients.some(i => \n          i.name.toLowerCase().includes(ingredient.toLowerCase())\n        )\n      )\n    );\n  }\n  \n  // Filter by health score\n  if (minHealthScore) {\n    results = results.filter(recipe => \n      recipe.dietCompassScores.overall >= minHealthScore\n    );\n  }\n  \n  // Filter by prep time\n  if (maxPrepTime) {\n    results = results.filter(recipe => \n      recipe.prepTime <= maxPrepTime\n    );\n  }\n  \n  // Sort results\n  if (sortBy) {\n    results.sort((a, b) => {\n      let valueA, valueB;\n      \n      switch (sortBy) {\n        case 'healthScore':\n          valueA = a.dietCompassScores.overall;\n          valueB = b.dietCompassScores.overall;\n          break;\n        case 'prepTime':\n          valueA = a.prepTime;\n          valueB = b.prepTime;\n          break;\n        case 'name':\n          return sortDirection === 'asc' \n            ? a.name.localeCompare(b.name)\n            : b.name.localeCompare(a.name);\n        default:\n          return 0;\n      }\n      \n      return sortDirection === 'asc' ? valueA - valueB : valueB - valueA;\n    });\n  }\n  \n  return results;\n}\n```",
        "testStrategy": "1. Test search with various queries\n2. Test filtering with different combinations of filters\n3. Test sorting with different criteria\n4. Verify performance with large catalogs\n5. Test UI interaction and responsiveness",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 116,
        "title": "Implement Recipe Detail Page Enhancement",
        "description": "Enhance the recipe detail page to display Diet Compass scores, health information, and parent-child relationships.",
        "details": "Enhance the recipe detail page:\n1. Display Diet Compass scores with visual indicators\n2. Show detailed nutrition information\n3. Display parent-child relationships\n4. Add 'Create Variation' button\n5. Show health impact of ingredients\n\nThe implementation should:\n- Create visual score bars for each health metric\n- Display detailed nutrition information in a table\n- Show parent recipe link if this is a variation\n- Show child variations if this recipe has any\n- Highlight protective and harmful ingredients\n\nExample implementation:\n```jsx\n// src/components/RecipeDetailPage.jsx\nimport React from 'react';\nimport { scoreToBarSegments } from '../utils/dietCompassScoring';\nimport { getRecipeWithRelationships } from '../utils/recipeRelationships';\n\nfunction RecipeDetailPage({ recipeId }) {\n  const [recipe, setRecipe] = useState(null);\n  \n  useEffect(() => {\n    const loadRecipe = async () => {\n      const recipeWithRelationships = await getRecipeWithRelationships(recipeId);\n      setRecipe(recipeWithRelationships);\n    };\n    \n    loadRecipe();\n  }, [recipeId]);\n  \n  if (!recipe) return <div>Loading...</div>;\n  \n  const handleCreateVariation = () => {\n    // Implementation from Task 104\n  };\n  \n  // Convert scores to bar segments (1-5)\n  const scoreSegments = {\n    overall: scoreToBarSegments(recipe.dietCompassScores.overall),\n    nutrientDensity: scoreToBarSegments(recipe.dietCompassScores.nutrientDensity),\n    antiAging: scoreToBarSegments(recipe.dietCompassScores.antiAging),\n    weightLoss: scoreToBarSegments(recipe.dietCompassScores.weightLoss),\n    heartHealth: scoreToBarSegments(recipe.dietCompassScores.heartHealth)\n  };\n  \n  return (\n    <div className=\"recipe-detail\">\n      <h1>{recipe.name}</h1>\n      \n      {/* Recipe image */}\n      {recipe.image && (\n        <img src={recipe.image} alt={recipe.name} className=\"recipe-image\" />\n      )}\n      \n      {/* Diet Compass scores */}\n      <div className=\"health-scores\">\n        <h2>Diet Compass Scores</h2>\n        \n        <div className=\"score-row\">\n          <span className=\"score-label\">Overall Health:</span>\n          <div className=\"score-bar\">\n            {Array(5).fill(0).map((_, i) => (\n              <div \n                key={i} \n                className={`score-segment ${i < scoreSegments.overall ? 'filled' : 'empty'}`}\n              />\n            ))}\n          </div>\n          <span className=\"score-value\">{recipe.dietCompassScores.overall}</span>\n        </div>\n        \n        <div className=\"score-row\">\n          <span className=\"score-label\">Nutrient Density ðŸ¥—:</span>\n          <div className=\"score-bar\">\n            {Array(5).fill(0).map((_, i) => (\n              <div \n                key={i} \n                className={`score-segment ${i < scoreSegments.nutrientDensity ? 'filled' : 'empty'}`}\n              />\n            ))}\n          </div>\n          <span className=\"score-value\">{recipe.dietCompassScores.nutrientDensity}</span>\n        </div>\n        \n        {/* Similar rows for other metrics */}\n      </div>\n      \n      {/* Relationships */}\n      {recipe.parentRecipeId && recipe.parentRecipe && (\n        <div className=\"parent-recipe\">\n          <p>Variation of: <a href={`/recipes/${recipe.parentRecipeId}`}>\n            {recipe.parentRecipe.name}\n          </a></p>\n          {recipe.variationNote && (\n            <p>Variation note: {recipe.variationNote}</p>\n          )}\n        </div>\n      )}\n      \n      {recipe.childRecipes && recipe.childRecipes.length > 0 && (\n        <div className=\"child-recipes\">\n          <h3>Variations:</h3>\n          <ul>\n            {recipe.childRecipes.map(child => (\n              <li key={child.recipeId}>\n                <a href={`/recipes/${child.recipeId}`}>{child.name}</a>\n                {child.variationNote && (\n                  <span className=\"variation-note\"> - {child.variationNote}</span>\n                )}\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n      \n      <button onClick={handleCreateVariation} className=\"variation-button\">\n        Create Variation\n      </button>\n      \n      {/* Rest of recipe details */}\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Test rendering with various recipe types\n2. Verify score bars display correctly\n3. Test parent-child relationship display\n4. Test 'Create Variation' functionality\n5. Verify nutrition information display",
        "priority": "medium",
        "dependencies": [
          "104",
          "105"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 117,
        "title": "Implement Settings UI for Prep Preferences",
        "description": "Enhance the settings UI to allow users to configure meal prep preferences for each day and meal.",
        "details": "Implement settings UI for prep preferences:\n1. Create a UI for configuring prep levels per day and meal\n2. Add batch prep day selection\n3. Save preferences to BaseSpecification\n4. Provide preset options for common patterns\n\nThe implementation should:\n- Create a grid layout for day Ã— meal settings\n- Allow selection of prep level (minimal/medium/full) for each cell\n- Add batch prep day selection (e.g., Saturday)\n- Include preset buttons for common patterns\n\nExample implementation:\n```jsx\n// src/components/PrepSettingsUI.jsx\nimport React, { useState } from 'react';\n\nfunction PrepSettingsUI({ baseSpecification, onSave }) {\n  const [prepLevels, setPrepLevels] = useState(baseSpecification.mealPrepSettings.prepLevels);\n  const [batchPrepDays, setBatchPrepDays] = useState(baseSpecification.mealPrepSettings.batchPrepDays);\n  \n  const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];\n  const meals = ['breakfast', 'lunch', 'dinner'];\n  const levels = ['minimal', 'medium', 'full'];\n  \n  const handlePrepLevelChange = (day, meal, level) => {\n    setPrepLevels(prev => ({\n      ...prev,\n      [day]: {\n        ...prev[day],\n        [meal]: level\n      }\n    }));\n  };\n  \n  const handleBatchPrepDayChange = (dayIndex, checked) => {\n    setBatchPrepDays(prev => {\n      if (checked) {\n        return [...prev, dayIndex].sort();\n      } else {\n        return prev.filter(d => d !== dayIndex);\n      }\n    });\n  };\n  \n  const applyPreset = (preset) => {\n    switch (preset) {\n      case 'weekdayMinimal':\n        // Minimal prep on weekdays, medium on weekends\n        setPrepLevels({\n          monday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'minimal' },\n          tuesday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'minimal' },\n          wednesday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'minimal' },\n          thursday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'minimal' },\n          friday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'minimal' },\n          saturday: { breakfast: 'medium', lunch: 'medium', dinner: 'medium' },\n          sunday: { breakfast: 'medium', lunch: 'medium', dinner: 'medium' }\n        });\n        setBatchPrepDays([6]); // Saturday\n        break;\n      case 'dinnerFocus':\n        // Focus prep on dinners\n        setPrepLevels({\n          monday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'medium' },\n          tuesday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'medium' },\n          wednesday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'medium' },\n          thursday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'medium' },\n          friday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'medium' },\n          saturday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'full' },\n          sunday: { breakfast: 'minimal', lunch: 'minimal', dinner: 'full' }\n        });\n        setBatchPrepDays([6]); // Saturday\n        break;\n      case 'fullPrep':\n        // Full prep for all meals\n        const fullPrep = {};\n        days.forEach(day => {\n          fullPrep[day] = {};\n          meals.forEach(meal => {\n            fullPrep[day][meal] = 'full';\n          });\n        });\n        setPrepLevels(fullPrep);\n        setBatchPrepDays([6, 0]); // Saturday and Sunday\n        break;\n      default:\n        break;\n    }\n  };\n  \n  const handleSave = () => {\n    onSave({\n      ...baseSpecification,\n      mealPrepSettings: {\n        prepLevels,\n        batchPrepDays\n      }\n    });\n  };\n  \n  return (\n    <div className=\"prep-settings\">\n      <h2>Meal Prep Preferences</h2>\n      \n      <div className=\"presets\">\n        <h3>Quick Setup:</h3>\n        <button onClick={() => applyPreset('weekdayMinimal')}>Weekday Minimal</button>\n        <button onClick={() => applyPreset('dinnerFocus')}>Dinner Focus</button>\n        <button onClick={() => applyPreset('fullPrep')}>Full Prep</button>\n      </div>\n      \n      <div className=\"batch-prep-days\">\n        <h3>Batch Prep Days:</h3>\n        {days.map((day, index) => (\n          <label key={day}>\n            <input\n              type=\"checkbox\"\n              checked={batchPrepDays.includes(index)}\n              onChange={(e) => handleBatchPrepDayChange(index, e.target.checked)}\n            />\n            {day.charAt(0).toUpperCase() + day.slice(1)}\n          </label>\n        ))}\n      </div>\n      \n      <div className=\"prep-level-grid\">\n        <table>\n          <thead>\n            <tr>\n              <th></th>\n              {meals.map(meal => (\n                <th key={meal}>{meal.charAt(0).toUpperCase() + meal.slice(1)}</th>\n              ))}\n            </tr>\n          </thead>\n          <tbody>\n            {days.map(day => (\n              <tr key={day}>\n                <td>{day.charAt(0).toUpperCase() + day.slice(1)}</td>\n                {meals.map(meal => (\n                  <td key={`${day}-${meal}`}>\n                    <select\n                      value={prepLevels[day][meal]}\n                      onChange={(e) => handlePrepLevelChange(day, meal, e.target.value)}\n                    >\n                      {levels.map(level => (\n                        <option key={level} value={level}>\n                          {level.charAt(0).toUpperCase() + level.slice(1)}\n                        </option>\n                      ))}\n                    </select>\n                  </td>\n                ))}\n              </tr>\n            ))}\n          </tbody>\n        </table>\n      </div>\n      \n      <button onClick={handleSave} className=\"save-button\">Save Preferences</button>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Test UI rendering with various initial settings\n2. Test changing prep levels for individual cells\n3. Test batch prep day selection\n4. Test preset application\n5. Verify saved settings match the UI state",
        "priority": "high",
        "dependencies": [
          "102"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 118,
        "title": "Implement Recipe Card Enhancement",
        "description": "Enhance recipe cards to display Diet Compass scores, diet profile compatibility, and variation indicators.",
        "details": "Enhance recipe cards:\n1. Add Diet Compass score visualization\n2. Display diet profile compatibility badges\n3. Add variation indicators for parent-child relationships\n4. Show effort level and prep time\n\nThe implementation should:\n- Create a compact score visualization with icons\n- Add diet profile badges (Keto, Vegan, etc.)\n- Indicate if a recipe is a variation or has variations\n- Show effort level and prep time in a user-friendly format\n\nExample implementation:\n```jsx\n// src/components/RecipeCard.jsx\nimport React from 'react';\nimport { scoreToBarSegments } from '../utils/dietCompassScoring';\n\nfunction RecipeCard({ recipe, showScores = true, showDietProfiles = true }) {\n  // Convert scores to bar segments (1-5)\n  const scoreSegments = showScores ? {\n    nutrientDensity: scoreToBarSegments(recipe.dietCompassScores.nutrientDensity),\n    antiAging: scoreToBarSegments(recipe.dietCompassScores.antiAging),\n    weightLoss: scoreToBarSegments(recipe.dietCompassScores.weightLoss),\n    heartHealth: scoreToBarSegments(recipe.dietCompassScores.heartHealth)\n  } : null;\n  \n  return (\n    <div className=\"recipe-card\">\n      {/* Recipe image */}\n      {recipe.image && (\n        <div className=\"recipe-image\">\n          <img src={recipe.image} alt={recipe.name} />\n        </div>\n      )}\n      \n      <div className=\"recipe-content\">\n        <h3 className=\"recipe-name\">\n          <a href={`/recipes/${recipe.recipeId}`}>{recipe.name}</a>\n          \n          {/* Variation indicator */}\n          {recipe.parentRecipeId && (\n            <span className=\"variation-badge\" title=\"Variation of another recipe\">â†—ï¸</span>\n          )}\n          {recipe.childRecipeIds && recipe.childRecipeIds.length > 0 && (\n            <span className=\"parent-badge\" title={`Has ${recipe.childRecipeIds.length} variations`}>â†˜ï¸</span>\n          )}\n        </h3>\n        \n        {/* Diet profile badges */}\n        {showDietProfiles && recipe.tags && recipe.tags.diets && recipe.tags.diets.length > 0 && (\n          <div className=\"diet-profiles\">\n            {recipe.tags.diets.map(diet => (\n              <span key={diet} className={`diet-badge ${diet}`}>\n                {diet}\n              </span>\n            ))}\n          </div>\n        )}\n        \n        {/* Effort and time */}\n        <div className=\"recipe-meta\">\n          <span className=\"effort-level\">\n            {recipe.tags.effortLevel === 'quick' && 'âš¡ï¸ Quick'}\n            {recipe.tags.effortLevel === 'easy' && 'ðŸ™‚ Easy'}\n            {recipe.tags.effortLevel === 'medium' && 'ðŸ‘¨â€ðŸ³ Medium'}\n            {recipe.tags.effortLevel === 'project' && 'ðŸ† Project'}\n          </span>\n          <span className=\"prep-time\">\n            {recipe.prepTime + recipe.cookTime} min\n          </span>\n        </div>\n        \n        {/* Diet Compass scores */}\n        {showScores && scoreSegments && (\n          <div className=\"compact-scores\">\n            <div className=\"score-item\">\n              <span className=\"score-icon\">ðŸ¥—</span>\n              <div className=\"score-bar\">\n                {Array(5).fill(0).map((_, i) => (\n                  <div \n                    key={i} \n                    className={`score-dot ${i < scoreSegments.nutrientDensity ? 'filled' : 'empty'}`}\n                  />\n                ))}\n              </div>\n            </div>\n            \n            <div className=\"score-item\">\n              <span className=\"score-icon\">â³</span>\n              <div className=\"score-bar\">\n                {Array(5).fill(0).map((_, i) => (\n                  <div \n                    key={i} \n                    className={`score-dot ${i < scoreSegments.antiAging ? 'filled' : 'empty'}`}\n                  />\n                ))}\n              </div>\n            </div>\n            \n            <div className=\"score-item\">\n              <span className=\"score-icon\">âš–ï¸</span>\n              <div className=\"score-bar\">\n                {Array(5).fill(0).map((_, i) => (\n                  <div \n                    key={i} \n                    className={`score-dot ${i < scoreSegments.weightLoss ? 'filled' : 'empty'}`}\n                  />\n                ))}\n              </div>\n            </div>\n            \n            <div className=\"score-item\">\n              <span className=\"score-icon\">â¤ï¸</span>\n              <div className=\"score-bar\">\n                {Array(5).fill(0).map((_, i) => (\n                  <div \n                    key={i} \n                    className={`score-dot ${i < scoreSegments.heartHealth ? 'filled' : 'empty'}`}\n                  />\n                ))}\n              </div>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Test rendering with various recipe types\n2. Verify score visualization displays correctly\n3. Test diet profile badges display\n4. Test variation indicators\n5. Verify responsive design on different screen sizes",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 119,
        "title": "Implement Multi-Profile Meal Display in UI",
        "description": "Enhance the meal plan UI to display multiple recipes for meals with conflicting diet profiles.",
        "details": "Implement multi-profile meal display:\n1. Update the DayView and MealPlanView components to handle multiple recipes per meal\n2. Display which eaters each recipe is for\n3. Show diet profile badges for each recipe\n4. Handle navigation to recipe details\n\nThe implementation should:\n- Detect meals with multiple recipes\n- Group recipes by target eaters\n- Display diet profile badges\n- Allow navigation to recipe details\n\nExample implementation:\n```jsx\n// src/components/MealCard.jsx\nimport React from 'react';\nimport RecipeCard from './RecipeCard';\n\nfunction MealCard({ meal, eaters, recipes }) {\n  // Group recipes by target eaters\n  const recipesByEater = {};\n  \n  // If meal has targetEaters field, use it to group recipes\n  if (meal.targetEaters && meal.targetEaters.length > 0) {\n    // This is a multi-profile meal\n    const recipe = recipes.find(r => r.recipeId === meal.recipeId);\n    if (recipe) {\n      const eaterNames = meal.targetEaters.map(eaterId => {\n        const eater = eaters.find(e => e.eaterId === eaterId);\n        return eater ? eater.name : 'Unknown';\n      });\n      \n      recipesByEater[eaterNames.join(', ')] = recipe;\n    }\n  } else {\n    // Regular meal, all eaters get the same recipe\n    const recipe = recipes.find(r => r.recipeId === meal.recipeId);\n    if (recipe) {\n      recipesByEater['Everyone'] = recipe;\n    }\n  }\n  \n  return (\n    <div className=\"meal-card\">\n      <h3 className=\"meal-type\">\n        {meal.mealType === 'breakfast' && 'ðŸŒ… Breakfast'}\n        {meal.mealType === 'lunch' && 'ðŸŒž Lunch'}\n        {meal.mealType === 'dinner' && 'ðŸŒ™ Dinner'}\n      </h3>\n      \n      {Object.entries(recipesByEater).map(([eaterNames, recipe]) => (\n        <div key={recipe.recipeId} className=\"recipe-for-eaters\">\n          {eaterNames !== 'Everyone' && (\n            <div className=\"eater-names\">For: {eaterNames}</div>\n          )}\n          <RecipeCard recipe={recipe} />\n        </div>\n      ))}\n      \n      {Object.keys(recipesByEater).length === 0 && (\n        <div className=\"no-recipe\">No recipe assigned</div>\n      )}\n    </div>\n  );\n}\n\n// src/components/DayView.jsx\nfunction DayView({ date, meals, eaters, recipes, prepLevels }) {\n  // Group meals by meal type\n  const mealsByType = {\n    breakfast: [],\n    lunch: [],\n    dinner: []\n  };\n  \n  meals.forEach(meal => {\n    if (meal.date === date) {\n      mealsByType[meal.mealType].push(meal);\n    }\n  });\n  \n  // Generate prep tasks for the day\n  const prepTasks = generatePrepTasks(meals.filter(m => m.date === date), prepLevels);\n  const totalPrepTime = prepTasks.reduce((total, task) => total + task.estimatedTime, 0);\n  \n  return (\n    <div className=\"day-view\">\n      <h2>{formatDate(date)}</h2>\n      \n      {/* Prep section */}\n      {prepTasks.length > 0 && (\n        <div className=\"prep-section\">\n          <h3>ðŸ“‹ Prep for Today (~{totalPrepTime} minutes)</h3>\n          <ul className=\"prep-tasks\">\n            {prepTasks.map((task, index) => (\n              <li key={index}>\n                <span className=\"task-description\">{task.task}</span>\n                <span className=\"task-time\">({task.estimatedTime} min)</span>\n                <span className=\"task-meals\">â†’ for {task.usedIn.join(' & ')}</span>\n              </li>\n            ))}\n          </ul>\n        </div>\n      )}\n      \n      {/* Meals */}\n      <div className=\"meals\">\n        {Object.entries(mealsByType).map(([mealType, mealsForType]) => (\n          <div key={mealType} className=\"meal-section\">\n            {mealsForType.length > 0 ? (\n              mealsForType.map(meal => (\n                <MealCard \n                  key={meal.mealId} \n                  meal={meal} \n                  eaters={eaters} \n                  recipes={recipes} \n                />\n              ))\n            ) : (\n              <div className=\"empty-meal\">\n                <h3 className=\"meal-type\">\n                  {mealType === 'breakfast' && 'ðŸŒ… Breakfast'}\n                  {mealType === 'lunch' && 'ðŸŒž Lunch'}\n                  {mealType === 'dinner' && 'ðŸŒ™ Dinner'}\n                </h3>\n                <div className=\"no-recipe\">No meal planned</div>\n              </div>\n            )}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n```",
        "testStrategy": "1. Test with various meal plan configurations\n2. Test with multi-profile households\n3. Verify correct display of recipes by eater\n4. Test navigation to recipe details\n5. Verify responsive design on different screen sizes",
        "priority": "high",
        "dependencies": [
          "101",
          "103"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-10T05:01:33.040Z",
      "taskCount": 20,
      "completedCount": 2,
      "tags": [
        "master"
      ],
      "created": "2026-01-10T05:25:28.725Z",
      "description": "Tasks for master context"
    }
  }
}