{
  "master": {
    "tasks": [
      {
        "id": "26",
        "title": "Implement Storage Utilities",
        "description": "Create centralized localStorage operations for eaters, recipes, meals, and current meal plan with quota error handling.",
        "details": "Create src/utils/storage.js with functions: loadEaters(), saveEaters(eaters[]), loadRecipes(), saveRecipes(recipes[]), loadMeals(), saveMeals(meals[]), loadCurrentMealPlan(), saveCurrentMealPlan(plan), safeSave(key, data). Use try-catch for QUOTA_EXCEEDED_ERR (code 22). Implement JSON.parse/stringify with validation. Generate IDs using `crypto.randomUUID()` for recipe_[uuid], meal_[uuid], etc. Deduplicate recipes by name+ingredients hash using Map. Follow Slice 1 patterns.",
        "testStrategy": "Unit test: save/load roundtrip for each data type, quota error simulation by filling localStorage, ID uniqueness (1000 generations), recipe deduplication with identical recipes.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Core CRUD Functions",
            "description": "Create load and save functions for eaters, recipes, meals, and current meal plan using localStorage with JSON.parse/stringify.",
            "dependencies": [],
            "details": "In src/utils/storage.js, implement loadEaters(), saveEaters(eaters[]), loadRecipes(), saveRecipes(recipes[]), loadMeals(), saveMeals(meals[]), loadCurrentMealPlan(), saveCurrentMealPlan(plan). Use specific storage keys like 'eaters', 'recipes', etc. Follow Slice 1 patterns for structure.",
            "status": "done",
            "testStrategy": "Unit test save/load roundtrip for each data type with sample data validation.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:02:01.068Z"
          },
          {
            "id": 2,
            "title": "Add Error Handling and Quota Management",
            "description": "Implement safeSave(key, data) with try-catch for QUOTA_EXCEEDED_ERR (code 22) and JSON validation.",
            "dependencies": [
              1
            ],
            "details": "Wrap all save operations in safeSave that catches QuotaExceededError, validates JSON.parse/stringify inputs, returns success/failure status. Add validation for array/object types before storage.",
            "status": "done",
            "testStrategy": "Unit test quota error simulation by pre-filling localStorage, validate error handling and fallback behavior.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:02:31.442Z"
          },
          {
            "id": 3,
            "title": "Implement ID Generation and Validation",
            "description": "Add ID generation using crypto.randomUUID() for recipe_[uuid], meal_[uuid] with uniqueness validation.",
            "dependencies": [
              1
            ],
            "details": "Create helper functions generateRecipeId(), generateMealId(). Ensure IDs are prefixed correctly. Add validation in load functions to check ID format and regenerate if invalid.",
            "status": "done",
            "testStrategy": "Unit test 1000 ID generations for uniqueness, validate prefix format, test invalid ID handling.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:02:49.389Z"
          },
          {
            "id": 4,
            "title": "Build Recipe Deduplication Algorithm",
            "description": "Implement deduplication by name+ingredients hash using Map in saveRecipes and related functions.",
            "dependencies": [
              1,
              3
            ],
            "details": "In saveRecipes(), create hash from recipe.name + sorted ingredients.join(','), use Map to track unique recipes, replace duplicates. Preserve original order, assign new IDs to unique recipes only.",
            "status": "done",
            "testStrategy": "Unit test with identical recipes (2+ same → 1 unique), different recipes preserved, hash collision resistance.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:03:16.260Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 4,
        "expansionPrompt": "Break down storage utilities into: 1) Core CRUD functions for each data type, 2) Error handling and quota management, 3) ID generation and validation logic, 4) Recipe deduplication algorithm with hashing.",
        "updatedAt": "2025-12-19T14:03:16.260Z"
      },
      {
        "id": "27",
        "title": "Add Generate Week Button to ChatWidget",
        "description": "Add prominent 'Generate Week' button to ChatWidget header that navigates to /generating route.",
        "details": "In src/components/ChatWidget.js, add button in header with styling: primary color, full-width, large font. On click: disable button, show loading spinner, dispatch custom event 'generate-week', navigate using router.go('/generating'). Button always visible regardless of chat state. Use existing router from Slice 1.",
        "testStrategy": "Manual: button visible on load, click triggers navigation to /generating, button disables during generation, re-enables on return.",
        "priority": "high",
        "dependencies": [
          "26"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Generate Week button to ChatWidget header",
            "description": "Insert prominent full-width button in the ChatWidget header section that is always visible regardless of chat state.",
            "dependencies": [],
            "details": "In src/components/ChatWidget.js, locate the header JSX element and add <button> element with text 'Generate Week'. Apply inline styles or CSS classes for primary color background, white text, full-width (width:100%), large font (font-size: 18px+), padding (16px 24px), border-radius 8px. Ensure button renders unconditionally outside any conditional chat state logic.",
            "status": "done",
            "testStrategy": "Manual: Verify button appears in header on initial page load in all chat states (empty, with messages)",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:03:53.617Z"
          },
          {
            "id": 2,
            "title": "Implement button click handler with disable and loading states",
            "description": "Create onClick handler that disables button and shows loading spinner immediately on click.",
            "dependencies": [
              1
            ],
            "details": "Add useState for isLoading (initial false). In onClick: setIsLoading(true). Replace button text with spinner (use existing spinner component or simple CSS spinner). Disable button with disabled={isLoading} attribute. Add conditional rendering: isLoading ? <Spinner/> : 'Generate Week'. Style spinner centered with same button dimensions.",
            "status": "done",
            "testStrategy": "Manual: Click button → immediately disables and shows spinner, text disappears",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:04:41.946Z"
          },
          {
            "id": 3,
            "title": "Dispatch custom generate-week event on button click",
            "description": "Dispatch 'generate-week' custom event to notify other components generation started.",
            "dependencies": [
              2
            ],
            "details": "In onClick handler (after setIsLoading(true)), add: window.dispatchEvent(new CustomEvent('generate-week', {detail: {source: 'chatwidget'}})). Ensure event bubbles and carries relevant payload. Place before navigation to allow parallel processing.",
            "status": "done",
            "testStrategy": "Manual: Click button → verify console shows 'generate-week' event fired (add temporary listener)",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:04:41.948Z"
          },
          {
            "id": 4,
            "title": "Implement router navigation to /generating route",
            "description": "Navigate to /generating route using existing Slice 1 router immediately after event dispatch.",
            "dependencies": [
              3
            ],
            "details": "Import router from Slice 1 (likely useRouter hook or router instance). In onClick after dispatch: router.go('/generating') or router.push('/generating'). Ensure navigation happens synchronously after event. Handle any router errors gracefully with console.warn.",
            "status": "done",
            "testStrategy": "Manual: Click button → browser navigates to /generating URL, button remains disabled",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:04:41.949Z"
          },
          {
            "id": 5,
            "title": "Add button re-enable logic and final polish",
            "description": "Implement logic to re-enable button when returning from /generating and apply final styling/accessibility.",
            "dependencies": [
              4
            ],
            "details": "Add useEffect listening for 'focus' or route change events to setIsLoading(false). Or use router events 'route-changed'. Ensure button accessible: add aria-label='Generate your weekly meal plan', role='button'. Final styles: box-shadow, hover:transform scale(1.02), focus:outline. Test mobile responsiveness (min-height:48px).",
            "status": "done",
            "testStrategy": "Manual: Complete flow - click→loading→navigate→return→button re-enables and clickable again",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:04:41.950Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": "2025-12-19T14:04:41.950Z"
      },
      {
        "id": "28",
        "title": "Create GenerationStatusPage Component",
        "description": "Build progress display page for meal plan generation with SSE streaming, progress bar, status messages, and auto-navigation.",
        "details": "Create src/components/GenerationStatusPage.js. Use SSE to connect to /api/generate-meal-plan. State: progress (0-100), status ('generating'|'complete'|'failed'), message. Features: animated progress bar (CSS transitions), status text, retry button (reconnect SSE), auto-navigate to '/' on complete. Handle SSE events: 'progress', 'error', 'complete'. Use AbortController for cleanup. Reuse Slice 1 SSE patterns.",
        "testStrategy": "Manual: progress updates in real-time (0→100), status messages change, complete auto-navigates, retry reconnects SSE, error shows retry button.",
        "priority": "high",
        "dependencies": [
          "27"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement SSE connection and event handling with AbortController",
            "description": "Create the SSE connection in GenerationStatusPage to /api/generate-meal-plan, wire up event listeners for progress, error, and complete events, and manage the AbortController lifecycle.",
            "dependencies": [],
            "details": "In src/components/GenerationStatusPage.js, set up the SSE client (using fetch/EventSource or existing Slice 1 helper) to connect to /api/generate-meal-plan when the component mounts. Instantiate an AbortController, pass its signal into the SSE/fetch call, and store it in a ref or state for later reuse. Add handlers for 'progress', 'error', and 'complete' events that parse event.data JSON safely, update local callbacks, and distinguish between terminal and non-terminal states. Ensure that abort() is called on unmount and when starting a new stream to avoid duplicate connections, reusing patterns from Slice 1 SSE utilities.",
            "status": "done",
            "testStrategy": "Manually verify that SSE connects, receives progress events at expected points, stops when aborted or on unmount, and that error/complete events arrive and are parsed without throwing.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:05:42.588Z"
          },
          {
            "id": 2,
            "title": "Build UI state management and animated progress display",
            "description": "Manage React state for progress, status, and message, and render an animated progress bar and status text that update in real time from SSE events.",
            "dependencies": [
              1
            ],
            "details": "Define React state variables: progress (0–100), status ('generating' | 'complete' | 'failed'), and message (string). In SSE event handlers from subtask 1, update these state values appropriately on 'progress', 'error', and 'complete' events. Implement a visual layout for GenerationStatusPage with a container, title, progress bar track and fill, and status/message text. Use CSS transitions on the progress bar width to animate changes smoothly. Conditionally render different messages and UI states based on status (e.g., loading spinner while generating, success text on complete, error text when failed). Ensure that initial state is generating with progress 0 and that rapid updates do not cause layout jumps.",
            "status": "done",
            "testStrategy": "Manual testing: trigger a generation and confirm the progress bar animates from 0 to 100 in steps, the status text and message update correctly for each stage, and visual transitions are smooth without console errors.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:05:42.589Z"
          },
          {
            "id": 3,
            "title": "Implement auto-navigation, retry behavior, and cleanup logic",
            "description": "Add logic to navigate back to the main route on completion, provide a retry button on error or failure, and ensure all resources are cleaned up properly.",
            "dependencies": [
              1,
              2
            ],
            "details": "Integrate the app’s router/navigation helper to automatically navigate to '/' when status becomes 'complete', with a short optional delay if desired. Show a retry button when status is 'failed' or on SSE error; on retry, abort any existing controller, reset state (progress=0, status='generating', message=''), and re-establish the SSE connection by invoking the same setup logic from subtask 1. Ensure cleanup in useEffect return: abort active SSE, remove any event listeners, and avoid double subscriptions (following Slice 1 patterns). Verify that navigating away from /generating cancels the stream and that navigating back creates a fresh, single connection. Handle edge cases where complete and error might race by only navigating when status is definitively 'complete'.",
            "status": "done",
            "testStrategy": "Manual flows: (1) Successful generation auto-navigates to '/', no extra network activity remains; (2) Forced error displays retry button, retry restarts the stream and UI without page reload; (3) Navigating away via back button or another route stops the stream and does not leak connections or timers.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:05:42.591Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Divide into: 1) SSE connection and event handling with AbortController, 2) UI state management and progress bar animations, 3) Auto-navigation, retry logic, and cleanup.",
        "updatedAt": "2025-12-19T14:05:42.591Z"
      },
      {
        "id": "29",
        "title": "Implement /api/generate-meal-plan Endpoint",
        "description": "Create Edge runtime API endpoint that generates meal plan using Claude with SSE progress streaming.",
        "details": "Create api/generate-meal-plan.js (Vercel Edge). POST body: {chatHistory[], eaters[]}. Use Anthropic SDK v1.0.0: model='claude-3-5-sonnet-20241022' (updated from PRD). System prompt enforces JSON schema. Stream Claude response, parse JSON chunks. Send SSE: progress events (10,25,50,75,90,100), final 'complete' with {recipes,meals,mealPlan}. Hardcode eaters if empty: [{name:'User',preferences:'no restrictions',schedule:'home for dinner'}]. 60s timeout. Validate input with Zod v3.23.8.",
        "testStrategy": "Integration: POST request returns SSE stream, progress events fire, complete event has valid normalized data, timeout handled gracefully.",
        "priority": "high",
        "dependencies": [
          "26",
          "28"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Input Validation with Zod",
            "description": "Create Zod schema validation for POST body {chatHistory[], eaters[]} with fallback for empty eaters array.",
            "dependencies": [],
            "details": "Define Zod schema for chatHistory (array of messages) and eaters (array of eater objects). Add fallback hardcoded eaters if empty: [{name:'User',preferences:'no restrictions',schedule:'home for dinner'}]. Use Zod v3.23.8. Validate early in handler.",
            "status": "done",
            "testStrategy": "Unit test: valid/invalid payloads, empty eaters fallback, Zod error messages.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:07:06.027Z"
          },
          {
            "id": 2,
            "title": "Setup Anthropic SDK Streaming with System Prompt",
            "description": "Configure Anthropic SDK v1.0.0 for claude-3-5-sonnet-20241022 with JSON schema enforcing system prompt.",
            "dependencies": [
              1
            ],
            "details": "Initialize Anthropic client with ANTHROPIC_API_KEY env var. Create system prompt enforcing JSON output schema for {recipes,meals,mealPlan}. Start streaming messages with validated input. Handle Edge runtime compatibility.",
            "status": "done",
            "testStrategy": "Unit test: client init, mock stream start, system prompt format validation.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:07:06.028Z"
          },
          {
            "id": 3,
            "title": "Implement SSE Response Streaming and JSON Parsing",
            "description": "Stream Claude response via SSE, parse JSON chunks incrementally, send final 'complete' event.",
            "dependencies": [
              2
            ],
            "details": "Set SSE headers for Edge runtime. Process stream chunks, accumulate JSON, parse when complete. Send 'complete' event with {recipes,meals,mealPlan}. Handle partial JSON parsing errors gracefully.",
            "status": "done",
            "testStrategy": "Integration test: mock stream yields valid JSON chunks → complete event received.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:07:06.029Z"
          },
          {
            "id": 4,
            "title": "Add Progress Event Simulation",
            "description": "Send SSE progress events at 10,25,50,75,90,100% during generation.",
            "dependencies": [
              3
            ],
            "details": "Simulate progress by sending SSE events at token intervals or timers during stream processing. Events: {progress:10}, {progress:25}, etc. Ensure smooth client-side progress bar updates.",
            "status": "done",
            "testStrategy": "Integration test: verify all 6 progress events fire in order during stream.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:07:06.030Z"
          },
          {
            "id": 5,
            "title": "Implement Timeout Handling and Error Cases",
            "description": "Add 60s timeout, error SSE events, and Edge runtime cleanup.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Use AbortController for 60s timeout on stream. Send 'error' SSE event on timeout/parsing failures. Cleanup resources properly for Edge runtime. Return 500 for unhandled errors.",
            "status": "done",
            "testStrategy": "Integration test: timeout after 60s → error event, stream abort cleans up.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:07:06.031Z"
          }
        ],
        "complexity": 9,
        "recommendedSubtasks": 5,
        "expansionPrompt": "Split into: 1) Input validation with Zod, 2) Anthropic SDK streaming setup with system prompt, 3) SSE response streaming and JSON chunk parsing, 4) Progress event simulation (10,25,50,75,90,100), 5) Timeout handling and error cases.",
        "updatedAt": "2025-12-19T14:07:06.031Z"
      },
      {
        "id": "30",
        "title": "Create Meal Plan Transformer Utility",
        "description": "Transform Claude's raw JSON output into normalized storage format with recipe deduplication and ID assignment.",
        "details": "Create src/utils/mealPlanTransformer.js. Function transformGeneratedPlan(claudeOutput). Steps: 1) Extract unique recipes (dedupe by name+ingredients using Map), assign recipeId=`recipe_${crypto.randomUUID()}`. 2) Create meals with mealId, reference recipeId, calculate servings from eaters. 3) Build mealPlan with weekOf (next Saturday), budget.estimated=sum(recipe costs). 4) Validate schemas with Zod. Return {recipes[], meals[], mealPlan}. Handle missing fields gracefully.",
        "testStrategy": "Unit test: transform valid Claude JSON→normalized data, deduplication (2 identical recipes→1), invalid JSON handled, budget calculation accurate, all IDs unique.",
        "priority": "high",
        "dependencies": [
          "26",
          "29"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement recipe extraction and deduplication with stable recipe IDs",
            "description": "Implement logic in src/utils/mealPlanTransformer.js to extract unique recipes from Claude's raw JSON output, deduplicate them using a name+ingredients hash, and assign stable recipeId values using crypto.randomUUID.",
            "dependencies": [],
            "details": "Create transformGeneratedPlan(claudeOutput) and inside it traverse Claude's recipe-like structures to collect recipes safely, guarding against missing or malformed fields. Build a Map keyed by a deterministic hash of lowercased recipe name plus a normalized ingredients list (e.g., sorted and trimmed) to deduplicate logically identical recipes. For each unique recipe, generate recipeId using the format `recipe_${crypto.randomUUID()}` and construct a normalized recipe object (fields like name, ingredients, instructions, cost if present), defaulting missing optional fields to safe values. Ensure the function returns an array of normalized recipes and exposes a mapping from the original recipe reference (e.g., index or name+hash) to the generated recipeId for later meal linking.",
            "status": "done",
            "testStrategy": "Unit test with sample Claude outputs: verify that two recipes with identical name and ingredients collapse into one entry, recipeId matches the required format, crypto.randomUUID is called per unique recipe, and missing fields (e.g., no instructions or cost) are handled without throwing.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:07:55.245Z"
          },
          {
            "id": 2,
            "title": "Create meals array with meal IDs, recipe references, and servings calculation",
            "description": "Using the deduplicated recipes and their IDs, implement creation of normalized meal objects that reference recipeId and compute servings from eaters data.",
            "dependencies": [
              1
            ],
            "details": "Extend transformGeneratedPlan to iterate over Claude's meal entries and create a flat meals[] collection. For each meal, generate a unique mealId (e.g., `meal_${crypto.randomUUID()}`), look up the correct recipeId from the recipe deduplication map, and attach any metadata such as meal type, day, or time if present. Implement servings calculation by deriving the servings count from the eaters array or equivalent field in claudeOutput (e.g., number of eaters assigned to that meal), falling back to a default (like 1) when data is missing. Ensure that meals with missing recipe data fail gracefully (skip or attach a null-safe placeholder) rather than crashing, and preserve a consistent normalized meal shape across all entries.",
            "status": "done",
            "testStrategy": "Unit test that meals are created for each input meal entry, each has a unique mealId, and all recipeId fields correspond to an existing recipe in the recipes array. Verify that when multiple eaters are attached to a meal, servings equals the eater count, and that when eaters are missing, a sensible default is used. Include a case where a meal references a non-existent recipe in the raw data and assert that the transformer handles it gracefully according to the chosen behavior (e.g., skipping or defaulting).",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:07:55.247Z"
          },
          {
            "id": 3,
            "title": "Assemble mealPlan object with weekOf, budget, and Zod validation",
            "description": "Compose the final mealPlan structure including weekOf (next Saturday), aggregated budget.estimated, run Zod validation for recipes/meals/mealPlan, and return the normalized payload.",
            "dependencies": [
              1,
              2
            ],
            "details": "In transformGeneratedPlan, compute weekOf by finding the calendar date of the next Saturday relative to the current date, format it consistently (e.g., ISO string), and build a mealPlan object that references this date and any other required metadata (such as label or createdAt if desired). Calculate budget.estimated as the sum of per-recipe costs derived from the normalized recipes array, guarding against missing or non-numeric cost fields by treating them as zero. Define Zod schemas for recipe, meal, and mealPlan objects (and possibly the overall return type) and validate the constructed data before returning. If validation fails, either throw a structured error or return a safe fallback according to project conventions, but never crash on minor missing optional fields. Finally, return an object of the form { recipes, meals, mealPlan } from the function.",
            "status": "done",
            "testStrategy": "Unit test end-to-end transformation: feed a valid Claude-style JSON and assert that the result matches the normalized shape, includes a weekOf date that is the next Saturday, and has budget.estimated equal to the sum of recipe costs. Add tests where some recipes lack cost to confirm they are treated as zero, and where the input violates the Zod schema to confirm that validation behavior (throw or safe fallback) works as designed.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:07:55.248Z"
          }
        ],
        "complexity": 7,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Break into: 1) Recipe extraction and deduplication by name+ingredients hash, 2) Meal creation with recipe ID references and servings calculation, 3) MealPlan assembly with weekOf/budget and Zod validation.",
        "updatedAt": "2025-12-19T14:07:55.248Z"
      },
      {
        "id": "31",
        "title": "Update HomePage for Meal Plan Display",
        "description": "Modify HomePage to show meal plan summary when exists, or generation prompt when no plan.",
        "details": "Update src/components/HomePage.js. On load: check loadCurrentMealPlan(). State A (no plan): hero + 'Chat with Vanessa'. State B (has plan): header 'Your meal plan for [weekOf]', stats card (21 meals, $XX budget), buttons: 'View Shopping List' (placeholder), 'Chat with Vanessa', 'Generate New Week' (triggers generate). Use loadMeals(), loadRecipes() for counts. Responsive grid layout.",
        "testStrategy": "Manual: no-plan state shows correctly, has-plan shows stats/buttons, 'Generate New Week' navigates to chat+generate, stats calculate correctly.",
        "priority": "medium",
        "dependencies": [
          "26",
          "30"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Conditional Rendering Logic for Meal Plan States",
            "description": "Add useEffect to load current meal plan on component mount and implement conditional rendering for no-plan (hero + Chat button) vs has-plan states using loadCurrentMealPlan() from storage utils.",
            "dependencies": [],
            "details": "In HomePage.js: useState for mealPlan state, useEffect calls loadCurrentMealPlan(), use ternary or if-else to render State A (hero section + 'Chat with Vanessa') or State B placeholder. Follow React best practices for clean conditional logic outside JSX.",
            "status": "done",
            "testStrategy": "Manual: Verify no-plan shows hero+chat, has-plan shows summary skeleton, state updates correctly on load.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:09:20.379Z"
          },
          {
            "id": 2,
            "title": "Build Stats Card, Buttons, and Responsive Grid Layout",
            "description": "Create has-plan UI with dynamic header, stats card using loadMeals()/loadRecipes() counts and budget, plus buttons for Shopping List (placeholder), Chat, Generate New Week (triggers generation).",
            "dependencies": [
              1
            ],
            "details": "Implement responsive CSS Grid/Flexbox layout. Stats: count meals (21), recipes, calculate budget total. Buttons: View Shopping List (alert/console placeholder), Chat with Vanessa (navigate/chat), Generate New Week (call generate function/navigate). Ensure mobile-first responsive design.",
            "status": "done",
            "testStrategy": "Manual: Stats display correct counts/budget, all buttons trigger correct actions, layout responsive across breakpoints, Generate button navigates properly.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:09:20.380Z"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Divide into: 1) Conditional rendering logic for no-plan vs has-plan states using storage utils, 2) Stats calculation and responsive UI layout with buttons.",
        "updatedAt": "2025-12-19T14:09:20.380Z"
      },
      {
        "id": "32",
        "title": "Add /generating Route to Router",
        "description": "Extend router system to handle new /generating route mapping to GenerationStatusPage.",
        "details": "Update src/utils/router.js. Add route: '/generating' → GenerationStatusPage. Ensure navigation from ChatWidget works. Preserve existing routes from Slice 1. Use same router pattern (history API or hash-based). Handle browser back button gracefully (don't lose generation state).",
        "testStrategy": "Manual: navigate to /generating shows correct page, back button returns to chat, route conflicts don't break existing pages.",
        "priority": "medium",
        "dependencies": [
          "28"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Review existing router implementation and routes in src/utils/router.js",
            "description": "Inspect the current router implementation and all existing Slice 1 routes to understand the routing pattern (history API or hash-based), navigation helpers, and back-button handling.",
            "dependencies": [],
            "details": "Open src/utils/router.js and identify how routes are declared (e.g., route table, switch statement, or custom router object), what routing mechanism is used (window.history API vs. hashchange), and how navigation is triggered from components (e.g., custom navigate() function). Document the existing route paths (including the main chat route) and any logic related to preserving state and handling browser back/forward events so that the new /generating route can follow the same conventions.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:06:06.474Z"
          },
          {
            "id": 2,
            "title": "Register /generating → GenerationStatusPage route in router configuration",
            "description": "Add a new route entry mapping the /generating path to the GenerationStatusPage component using the same pattern as existing routes.",
            "dependencies": [
              1,
              2
            ],
            "details": "In src/utils/router.js, import GenerationStatusPage from its defined path (e.g., src/components/GenerationStatusPage) and extend the router’s route map to include a '/generating' key pointing to GenerationStatusPage. Ensure the registration syntax (object map, array of routes, or JSX-based router) matches the existing implementation and does not modify or remove any pre-existing Slice 1 route definitions. Confirm that the new route participates in the same history or hash-based behavior already in use.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:06:06.476Z"
          },
          {
            "id": 3,
            "title": "Enable navigation from ChatWidget to /generating route",
            "description": "Wire the ChatWidget component (or related trigger) to navigate programmatically to /generating when meal plan generation starts or when appropriate.",
            "dependencies": [
              1,
              2
            ],
            "details": "Locate the ChatWidget component and identify where generation is initiated or where the UI should transition to the generation status view. Use the existing navigation helper (e.g., navigate('/generating') or history.push('/generating')) provided by src/utils/router.js to route to '/generating'. Ensure that the call site follows the established pattern for navigation from other components and does not break the chat flow or event handling.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:06:06.478Z"
          },
          {
            "id": 4,
            "title": "Verify back-button behavior and generation state preservation for /generating",
            "description": "Ensure that when users navigate to /generating and then use the browser back button, navigation returns to the previous chat page without losing in-progress generation state.",
            "dependencies": [
              2,
              3
            ],
            "details": "Manually test the flow: navigate from the chat page to /generating via ChatWidget, then use the browser back button and confirm the app returns to the chat route while preserving any relevant generation state (e.g., stored in context, Redux, or localStorage). If needed, adjust router popstate/hashchange handling or state management integration so that back/forward navigation does not reset or discard the in-progress generation status. Keep any modifications consistent with existing Slice 1 back-button handling logic.",
            "status": "done",
            "testStrategy": "Manual: start generation from chat, confirm navigation to /generating, click browser Back, verify return to chat with generation state intact and no full reload or unexpected resets.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:06:06.479Z"
          },
          {
            "id": 5,
            "title": "Regression test all routes including new /generating mapping",
            "description": "Perform a focused regression pass on the routing system to ensure existing routes still function and that /generating behaves correctly in combination with them.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Manually navigate to all known Slice 1 routes using both direct URL entry and in-app links, confirming pages render as before. Test entering /generating directly in the browser address bar, navigating between chat and /generating multiple times, and using browser back/forward across different routes. Check that there are no unexpected 404s, rendering errors, or route conflicts and that the router mechanism (history or hash) behaves uniformly across all routes, including the new /generating route.",
            "status": "done",
            "testStrategy": "Manual: smoke-test every defined route, direct-load /generating, and use Back/Forward to move between chat, /generating, and at least one other existing route to confirm no regressions.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:06:06.481Z"
          }
        ],
        "complexity": 3,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": "2025-12-19T14:06:06.481Z"
      },
      {
        "id": "33",
        "title": "Save Generated Data to localStorage on Completion",
        "description": "Automatically persist complete meal plan data using storage utilities when generation finishes.",
        "details": "In GenerationStatusPage 'complete' handler: call saveRecipes(data.recipes), saveMeals(data.meals), saveCurrentMealPlan(data.mealPlan). Dispatch custom event 'plan-generated'. Use safeSave() with ErrorHandler.handleStorageError(). Validate data before save using Zod schemas matching PRD.",
        "testStrategy": "Integration: after complete SSE, verify localStorage contains 'recipes','meals','currentMealPlan' with correct data, quota error shows warning.",
        "priority": "medium",
        "dependencies": [
          "26",
          "30",
          "28"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Review GenerationStatusPage complete handler and data shape",
            "description": "Inspect the existing GenerationStatusPage component and its SSE 'complete' event handler to understand the structure of data.recipes, data.meals, and data.mealPlan and how they map to PRD requirements.",
            "dependencies": [],
            "details": "Open src/components/GenerationStatusPage.js (or equivalent) and locate the SSE 'complete' event handler. Confirm the payload shape for data.recipes, data.meals, and data.mealPlan coming from /api/generate-meal-plan. Cross-check these structures against the PRD so you know what the Zod schemas must validate and what the storage utilities must accept. Document any mismatches or assumptions in comments for later adjustment.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:08:29.266Z"
          },
          {
            "id": 2,
            "title": "Define or update Zod schemas for recipes, meals, and mealPlan data",
            "description": "Create or refine Zod schemas that validate the recipes, meals, and mealPlan objects returned on completion, ensuring they match the PRD data contract.",
            "dependencies": [
              1
            ],
            "details": "In the shared validation module (or a new file if needed), add or update Zod schemas for Recipe, Meal, and MealPlan collections that match the PRD fields and types. Export schemas such as RecipesSchema, MealsSchema, CurrentMealPlanSchema. Ensure schemas accept exactly the fields produced by the generate-meal-plan endpoint and used by the UI. Include safe defaults and narrowing (e.g., enums) where specified by the PRD so invalid payloads can be rejected before storage.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:08:29.267Z"
          },
          {
            "id": 3,
            "title": "Integrate Zod validation into GenerationStatusPage complete handler",
            "description": "Apply the Zod schemas to validate SSE completion data before attempting to save it to localStorage.",
            "dependencies": [
              2
            ],
            "details": "In GenerationStatusPage's 'complete' handler, import the Zod schemas and validate data.recipes, data.meals, and data.mealPlan. Use safeParse or try/catch around schema.parse to avoid throwing unhandled errors. If validation fails, log or surface an appropriate error via existing ErrorHandler patterns and skip persisting invalid sections. Keep the validation logic small and focused, reusing any shared helpers for schema validation if the project already has them.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:08:29.268Z"
          },
          {
            "id": 4,
            "title": "Wire storage utilities with safeSave and storage error handling",
            "description": "Call saveRecipes, saveMeals, and saveCurrentMealPlan using safeSave and ErrorHandler.handleStorageError within the complete handler to persist validated data.",
            "dependencies": [
              3
            ],
            "details": "Import saveRecipes, saveMeals, saveCurrentMealPlan, safeSave, and ErrorHandler.handleStorageError into GenerationStatusPage. In the 'complete' handler, after successful validation, wrap each storage call in safeSave so quota and other storage errors are caught. On failure, call ErrorHandler.handleStorageError() with the thrown error and a suitable context message. Ensure storage keys and formats match existing conventions (e.g., 'recipes', 'meals', 'currentMealPlan') and that saves are independent so one failure does not prevent others from being attempted.",
            "status": "done",
            "testStrategy": null,
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:08:29.269Z"
          },
          {
            "id": 5,
            "title": "Dispatch plan-generated event and verify end-to-end behavior",
            "description": "Emit a custom 'plan-generated' event after successful saves and confirm that localStorage and event consumers behave as expected.",
            "dependencies": [
              4
            ],
            "details": "At the end of the 'complete' handler, after attempting storage operations, dispatch a CustomEvent('plan-generated', { detail: { recipes, meals, mealPlan } }) on window or the agreed event target. Then perform the integration testing described in the parent task: trigger a full SSE generation flow, confirm that localStorage contains the expected 'recipes', 'meals', and 'currentMealPlan' entries with correct serialized data, and verify that quota errors surface via the error handler (e.g., user-visible warning). If other components listen for 'plan-generated', confirm they react correctly without breaking navigation or status display.",
            "status": "done",
            "testStrategy": "Manual/integration: run generation flow, inspect localStorage keys and values, simulate storage quota or unavailable storage (e.g., using dev tools) to ensure ErrorHandler is called, and listen for the 'plan-generated' event in a simple test listener to confirm it fires with the correct detail payload.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:08:29.270Z"
          }
        ],
        "complexity": 4,
        "recommendedSubtasks": 0,
        "expansionPrompt": "",
        "updatedAt": "2025-12-19T14:08:29.270Z"
      },
      {
        "id": "34",
        "title": "Implement Error Handling and Retry Logic",
        "description": "Add comprehensive error handling for generation failures, storage errors, and network issues.",
        "details": "Extend GenerationStatusPage: SSE 'error'→show retry button + message. Retry: reconnect SSE with same POST body. Storage errors→ErrorHandler.handleStorageError(). Timeout (60s)→show 'Generation taking longer...' + retry. Network errors→'Connection lost, retry?'. Log all errors to console with structured data. Add 'Start Over' button clears state, navigates to '/'.",
        "testStrategy": "Manual: simulate SSE error→retry works, storage quota exceeded→warning shown, network disconnect→retry available, timeout→retry button appears.",
        "priority": "medium",
        "dependencies": [
          "28",
          "33"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement SSE error UI, retry button, and reconnection with preserved POST body",
            "description": "Extend GenerationStatusPage to handle SSE 'error' events by showing a clear error message and retry button, and on retry reconnect to the SSE endpoint using the original POST body.",
            "dependencies": [],
            "details": "Update GenerationStatusPage to subscribe to SSE error events and, when triggered, display an inline error state with a descriptive message and a dedicated Retry button. Store the original POST body used to initiate the SSE connection so that clicking Retry reconstructs and reopens the SSE connection using the same payload. Ensure the UI state (loading/progress indicators) resets appropriately on retry. Keep the implementation consistent with existing SSE wiring and state management patterns already used in the page.",
            "status": "done",
            "testStrategy": "Manually induce an SSE error (e.g., via mocked endpoint or dev tools) and verify that the error message and Retry button appear, that clicking Retry re-establishes the SSE connection with the same POST body, and that progress updates resume normally.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:10:00.925Z"
          },
          {
            "id": 2,
            "title": "Add timeout, network, and storage error handling with logging and 'Start Over' behavior",
            "description": "Implement 60s timeout handling, network error messaging, storage error delegation to ErrorHandler.handleStorageError, structured console logging, and a 'Start Over' button that clears state and navigates to the home route.",
            "dependencies": [
              1
            ],
            "details": "Introduce a 60-second timer around the generation flow; when exceeded, transition the UI to a timeout state that shows a 'Generation taking longer...' message and offers a Retry option. Detect network-level failures during SSE or related requests and present a 'Connection lost, retry?' message with a retry action. For any storage-related failures encountered while saving generation results or related data, call ErrorHandler.handleStorageError() and surface any necessary user feedback according to existing patterns. For every error type (SSE, timeout, network, storage), log a structured object to console (including type, message, stack or raw error, and relevant context such as request body or timestamps). Add a 'Start Over' button that clears all in-memory generation status/state for the page and programmatically navigates the user back to the '/' route, ensuring no stale error or progress state persists.",
            "status": "done",
            "testStrategy": "Manually simulate: (1) a long-running generation that exceeds 60 seconds and verify the timeout message, logging, and retry behavior; (2) a network disconnect or failed request to confirm the 'Connection lost, retry?' UI and structured logs; (3) a storage quota or write error to ensure ErrorHandler.handleStorageError is invoked and errors are logged; and (4) use the 'Start Over' button to confirm state is reset and navigation to '/' occurs without residual UI state.",
            "parentId": "undefined",
            "updatedAt": "2025-12-19T14:10:00.926Z"
          }
        ],
        "complexity": 6,
        "recommendedSubtasks": 2,
        "expansionPrompt": "Split into: 1) SSE error/retry UI and reconnection logic, 2) Timeout, network, and storage error handling with logging and 'Start Over' functionality.",
        "updatedAt": "2025-12-19T14:10:00.926Z"
      },
      {
        "id": "35",
        "title": "End-to-End Testing and Polish",
        "description": "Test complete generation flow, add UI polish, and handle edge cases per testing strategy.",
        "details": "Test full flow: chat→generate→progress→plan display. Edge cases: rapid double-click generate (debounce), corrupt Claude JSON (fallback message), multiple generations (overwrite currentPlan), offline viewing (load existing plan). UI polish: smooth progress animations (CSS @keyframes), loading skeletons, responsive design. Add custom event listeners for 'plan-generated' across components.",
        "testStrategy": "E2E manual: happy path 3x, double-click generate, network disconnect mid-stream, storage quota full, corrupt API response, browser refresh during generation.",
        "priority": "low",
        "dependencies": [
          "27",
          "28",
          "29",
          "30",
          "31",
          "32",
          "33",
          "34"
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Perform E2E flow testing for happy paths and critical edge cases",
            "description": "Manually exercise the complete chat→generate→progress→plan display flow several times, validating that it behaves correctly for the happy path and for all specified edge cases.",
            "dependencies": [],
            "details": "Run the full generation flow end-to-end at least three times for the happy path, verifying SSE progress updates, status transitions, and final plan rendering. Then manually test each edge case from the test strategy: rapid double-click on generate (debounce prevents duplicate requests), corrupt or malformed Claude JSON response (fallback message shown without breaking UI), multiple consecutive generations (currentPlan is correctly overwritten and old state cleared), offline or network disconnect scenarios mid-stream (existing plan loaded or appropriate retry/timeout messaging shown), storage quota full and browser refresh during generation. Document observed behavior and create or update bug tickets for any deviations from expected outcomes.",
            "status": "pending",
            "testStrategy": "Manual E2E execution using browser devtools and network throttling to simulate errors, following the defined test strategy items one by one and logging pass/fail per scenario.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Apply and verify UI polish for progress, skeletons, and responsiveness",
            "description": "Refine and test the UI polish aspects of the generation flow, including animations, loading skeletons, and responsive layout behavior across viewports.",
            "dependencies": [
              1
            ],
            "details": "Implement or fine-tune CSS @keyframes for smooth progress bar and status transitions on the GenerationStatusPage and any related components. Add or adjust loading skeleton components for chat, progress view, and final plan display to ensure visually consistent placeholders while data loads. Verify responsive layouts on common breakpoints (mobile, tablet, desktop), checking that progress indicators, buttons, and plan cards do not overflow or overlap. Confirm that animations perform smoothly without jank and that they do not interfere with accessibility (e.g., reduced motion preferences if supported). Capture before/after screenshots or video for future regression comparison.",
            "status": "pending",
            "testStrategy": "Manual visual QA across multiple viewport sizes and browsers, validating animations, skeleton states, and responsive layout with browser devtools and design checklist.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Integrate and test event listeners and debouncing across components",
            "description": "Wire up custom 'plan-generated' event listeners across components and ensure debounced generate actions prevent duplicate flows.",
            "dependencies": [
              1,
              2
            ],
            "details": "Review the component hierarchy for the generation flow and add consistent custom event dispatching for the 'plan-generated' event at the point where a plan is successfully created. Register event listeners in all components that must react to this event (e.g., navigation, state management, offline cache), ensuring they update or clear state correctly. Implement or confirm a debouncing mechanism for the generate action to handle rapid double-clicks, ensuring only one generation request is active at a time and subsequent clicks are ignored or queued as per requirements. Test multiple quick clicks, repeated generations, and navigation back/forward to confirm listeners are not duplicated or leaked and that currentPlan is always in a coherent state.",
            "status": "pending",
            "testStrategy": "Manual interaction tests focused on rapid user actions and repeated generations, combined with console logging or devtools inspection to confirm single event firing, no duplicate listeners, and correct state updates.",
            "parentId": "undefined"
          }
        ],
        "complexity": 5,
        "recommendedSubtasks": 3,
        "expansionPrompt": "Divide into: 1) E2E flow testing (happy path + edge cases), 2) UI polish (animations, skeletons, responsive), 3) Event listener integration and debouncing."
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2025-12-19T14:10:00.927Z",
      "taskCount": 10,
      "completedCount": 9,
      "tags": [
        "master"
      ]
    }
  }
}