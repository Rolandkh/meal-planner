{
  "master": {
    "tasks": [
      {
        "id": 57,
        "title": "Fix Recipe Edit Page Critical Bugs",
        "description": "Address three critical bugs in the Recipe Edit page: non-functional Add Ingredient button, missing save confirmation feedback, and data persistence issues.",
        "details": "This task involves fixing three critical bugs in the Recipe Edit page:\n\n1. **Fix Add Ingredient Button**:\n- Debug the click handler in RecipeEditPage.js\n- Implement functionality to add a new blank ingredient row with empty fields for name, amount, unit, and category\n- Ensure the new row is immediately editable\n\n```javascript\n// Example implementation for Add Ingredient button handler\nconst handleAddIngredient = () => {\n  setIngredients(prevIngredients => [\n    ...prevIngredients,\n    { name: '', amount: '', unit: '', category: '' }\n  ]);\n};\n```\n\n2. **Implement Save Confirmation UI**:\n- Add visual feedback when save is clicked\n- Update button state management (blue ‚Üí green ‚Üí blue)\n- Change button text from \"Save Changes\" to \"Saved ‚úì\" on success\n- Implement a 5-second timer for auto-reset\n- Add error state handling if save fails\n\n```javascript\n// Example implementation for save confirmation\nconst handleSave = async () => {\n  setSaveState('saving'); // Could be 'idle', 'saving', 'success', 'error'\n  try {\n    await saveRecipe(recipeData);\n    setSaveState('success');\n    // Reset after 5 seconds\n    setTimeout(() => setSaveState('idle'), 5000);\n  } catch (error) {\n    setSaveState('error');\n    console.error('Failed to save recipe:', error);\n    // Reset after 5 seconds\n    setTimeout(() => setSaveState('idle'), 5000);\n  }\n};\n```\n\n3. **Fix Data Persistence**:\n- Debug storage integration to ensure `saveRecipes()` or `updateRecipe()` is being called correctly\n- Verify recipe ID is preserved to prevent duplicates\n- Ensure all field changes are captured and persisted to localStorage\n- Verify data is correctly read back on page load\n\n```javascript\n// Example implementation for data persistence\nconst saveRecipe = (recipeData) => {\n  // Get existing recipes from localStorage\n  const existingRecipes = JSON.parse(localStorage.getItem('recipes') || '[]');\n  \n  // Find if recipe already exists\n  const recipeIndex = existingRecipes.findIndex(r => r.id === recipeData.id);\n  \n  if (recipeIndex >= 0) {\n    // Update existing recipe\n    existingRecipes[recipeIndex] = recipeData;\n  } else {\n    // Add new recipe\n    existingRecipes.push(recipeData);\n  }\n  \n  // Save back to localStorage\n  localStorage.setItem('recipes', JSON.stringify(existingRecipes));\n};\n```",
        "testStrategy": "1. **Unit Testing**:\n   - Write unit tests for the Add Ingredient button functionality\n   - Test save confirmation UI state transitions\n   - Test data persistence functions with mock localStorage\n\n2. **Integration Testing**:\n   - Test the complete save workflow from form input to storage and retrieval\n   - Verify recipe data integrity after save and reload\n\n3. **Manual Testing**:\n   - Add multiple ingredients and verify they appear correctly\n   - Edit existing ingredients and verify changes persist\n   - Test save confirmation UI appearance and timing\n   - Navigate away from and back to the recipe edit page to verify persistence\n   - Verify no duplicate recipes are created\n\n4. **Cross-browser Testing**:\n   - Test on Chrome, Firefox, Safari, and Edge\n   - Test on both desktop and mobile devices\n\n5. **Edge Cases**:\n   - Test with very large recipes (many ingredients)\n   - Test with special characters in recipe fields\n   - Test with empty required fields",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Debug and Fix Add Ingredient Button Handler",
            "description": "Locate the Add Ingredient button in RecipeEditPage.js, debug the existing click handler issue, and implement the provided handleAddIngredient function to add a new blank ingredient row.",
            "dependencies": [],
            "details": "Inspect the onClick prop binding for the Add Ingredient button. Replace or add the handleAddIngredient function using setIngredients to append { name: '', amount: '', unit: '', category: '' }. Ensure the new row renders with editable input fields immediately.",
            "status": "done",
            "testStrategy": "Unit test handleAddIngredient with mocked setIngredients state updater. Verify new row is added to ingredients array. Integration test: Click button and confirm new editable row appears in UI.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T00:38:58.285Z"
          },
          {
            "id": 2,
            "title": "Implement Save Button State Management",
            "description": "Add saveState state variable and integrate it with the Save button to handle idle, saving, success, and error states with appropriate visual feedback.",
            "dependencies": [
              1
            ],
            "details": "Create useState for saveState with values 'idle'|'saving'|'success'|'error'. Update Save button to show loading spinner for 'saving', green background/text 'Saved ‚úì' for 'success', and red for 'error'. Implement 5-second auto-reset timeout.",
            "status": "done",
            "testStrategy": "Unit tests for state transitions: idle‚Üísaving‚Üísuccess‚Üíidle and idle‚Üísaving‚Üíerror‚Üíidle. Mock saveRecipe function. Verify button text/color changes correctly.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T00:38:58.287Z"
          },
          {
            "id": 3,
            "title": "Integrate Save Confirmation with saveRecipe API",
            "description": "Wire the handleSave function to call saveRecipe with current recipeData, handle success/error responses, and trigger state updates for confirmation UI.",
            "dependencies": [
              2
            ],
            "details": "Implement async handleSave using provided example: setSaveState('saving'), await saveRecipe(recipeData), setSaveState('success') or 'error'. Add try/catch with console.error logging. Ensure recipeData captures all form fields including ingredients array.",
            "status": "done",
            "testStrategy": "Integration test full save flow: modify form ‚Üí click Save ‚Üí verify API call with correct data ‚Üí confirm success state ‚Üí verify auto-reset. Test error handling with mocked failed save.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T00:38:58.289Z"
          },
          {
            "id": 4,
            "title": "Fix Recipe Data Persistence in localStorage",
            "description": "Debug and implement the saveRecipe function to correctly update existing recipes by ID or add new ones, ensuring no duplicates and proper localStorage serialization.",
            "dependencies": [
              3
            ],
            "details": "Use provided saveRecipe implementation: parse existing recipes from localStorage, find by recipeData.id, update or push new, stringify and save back. Ensure recipe.id is preserved throughout edit flow. Verify load logic reads correct recipe by ID.",
            "status": "done",
            "testStrategy": "Unit test saveRecipe with mock localStorage: test update existing recipe, test add new recipe, test ID preservation. Verify no duplicates created. Test load recipe displays correct persisted data.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T00:38:58.290Z"
          },
          {
            "id": 5,
            "title": "End-to-End Testing and Final Validation",
            "description": "Test complete Recipe Edit workflow: add ingredients, edit fields, save with confirmation, reload page to verify persistence across sessions.",
            "dependencies": [
              4
            ],
            "details": "Manual E2E testing: Create/edit recipe ‚Üí Add multiple ingredients ‚Üí Save ‚Üí Verify green confirmation ‚Üí Refresh page ‚Üí Confirm data persists ‚Üí Edit again ‚Üí Save ‚Üí Verify updates. Check localStorage contents match UI.\n<info added on 2026-01-08T00:39:07.994Z>\nImplementation complete for all fixes. Ready for end-to-end testing.\n\nTesting instructions:\n1. Create a new recipe or edit an existing one\n2. Test Add Ingredient button - should add a new ingredient row without page refresh\n3. Test Remove Ingredient button - should remove the selected ingredient without affecting others\n4. Add multiple ingredients and modify recipe fields\n5. Save the recipe and verify the button turns green with \"Saved ‚úì\" text for 5 seconds\n6. Refresh the page and confirm all data persists correctly\n7. Edit the recipe again and save to verify no duplicate entries are created\n8. Check localStorage contents to ensure they match what's displayed in the UI\n\nCode changes summary:\n- Fixed Add/Remove Ingredient buttons by calling renderIngredients() instead of render()\n- Implemented saveSuccess state and updateSaveButton() method\n- Added 5-second green confirmation after successful save\n- Prevented immediate navigation after save\n- Added proper cleanup for save success timeout\n- All code passes linter checks\n\nModified files:\n- src/components/RecipeEditPage.js\n</info added on 2026-01-08T00:39:07.994Z>",
            "status": "done",
            "testStrategy": "Comprehensive E2E test suite: 1) Add ingredient + save + reload verification 2) Edit all fields + save confirmation states 3) Error handling simulation 4) Multiple save cycles without data loss 5) Cross-browser compatibility check.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T00:55:40.320Z"
          }
        ],
        "updatedAt": "2026-01-08T00:55:40.320Z"
      },
      {
        "id": 58,
        "title": "Implement Single-Day Regeneration Workflow",
        "description": "Fix the data loss bug in single-day regeneration and implement a conversational workflow for making changes to a specific day's meal plan while preserving the rest of the week.",
        "details": "This task involves fixing the critical issue where regenerating a single day causes the entire week to be deleted. The implementation will create a conversational workflow for updating a single day:\n\n1. **Add \"Make Changes\" Button to DayView**:\n- Update DayView.js to include a \"Make Changes\" button at the top of each day view\n- Style the button to be visible but not intrusive\n\n```javascript\n// Example implementation in DayView.js\nconst DayView = ({ day, date, meals }) => {\n  return (\n    <div className=\"day-view\">\n      <div className=\"day-header\">\n        <h2>{day} - {formatDate(date)}</h2>\n        <button \n          className=\"make-changes-btn\"\n          onClick={() => handleMakeChanges(day, date, meals)}\n        >\n          Make Changes\n        </button>\n      </div>\n      {/* Rest of day view */}\n    </div>\n  );\n};\n```\n\n2. **Update regenerateDay() Function**:\n- Modify regenerateDay.js to preserve other days in the meal plan\n- Ensure only the targeted day gets replaced\n\n```javascript\n// Example implementation in regenerateDay.js\nconst regenerateDay = async (dayToUpdate, userConstraints) => {\n  // Get current meal plan\n  const currentMealPlan = getCurrentMealPlan();\n  \n  // Generate new day content\n  const newDayContent = await generateDayMealPlan(dayToUpdate, userConstraints);\n  \n  // Find the index of the day to update\n  const dayIndex = currentMealPlan.days.findIndex(day => day.name === dayToUpdate);\n  \n  if (dayIndex >= 0) {\n    // Replace only that specific day\n    currentMealPlan.days[dayIndex] = {\n      ...currentMealPlan.days[dayIndex],\n      ...newDayContent\n    };\n  }\n  \n  // Save updated meal plan\n  saveMealPlan(currentMealPlan);\n  \n  return currentMealPlan;\n};\n```\n\n3. **Extend ChatWidget for Day-Specific Changes**:\n- Update ChatWidget.js to handle day-specific change requests\n- Add context awareness so Vanessa knows which day is being modified\n\n```javascript\n// Example implementation in ChatWidget.js\nconst ChatWidget = ({ isOpen, onClose, dayContext }) => {\n  useEffect(() => {\n    if (isOpen && dayContext) {\n      // Initialize chat with contextual prompt\n      const initialPrompt = `So you want to make changes to ${dayContext.day}'s menu. What would you like to change?`;\n      setMessages(prev => [...prev, { role: 'assistant', content: initialPrompt }]);\n    }\n  }, [isOpen, dayContext]);\n  \n  // Rest of chat widget implementation\n};\n```\n\n4. **Update API Endpoint**:\n- Modify api/generate-meal-plan.js to support partial meal plan updates\n- Add parameters for day-specific regeneration\n\n```javascript\n// Example API endpoint update\nasync function handler(req, res) {\n  const { day, constraints, preserveOtherDays = true } = req.body;\n  \n  try {\n    if (day && preserveOtherDays) {\n      // Single day regeneration\n      const updatedMealPlan = await regenerateSingleDay(day, constraints);\n      res.status(200).json(updatedMealPlan);\n    } else {\n      // Full week regeneration (existing functionality)\n      const newMealPlan = await generateFullMealPlan(constraints);\n      res.status(200).json(newMealPlan);\n    }\n  } catch (error) {\n    res.status(500).json({ error: error.message });\n  }\n}\n```",
        "testStrategy": "1. **Unit Testing**:\n   - Test the regenerateDay() function with various inputs\n   - Verify it correctly preserves other days\n   - Test the ChatWidget initialization with day context\n\n2. **Integration Testing**:\n   - Test the full workflow from button click to chat opening to day regeneration\n   - Verify API calls are made with correct parameters\n   - Test with various constraint scenarios\n\n3. **End-to-End Testing**:\n   - Click \"Make Changes\" on a specific day\n   - Verify chat opens with correct contextual prompt\n   - Complete conversation flow with ingredient constraints\n   - Verify only the selected day is updated\n   - Confirm all other days remain unchanged\n\n4. **Regression Testing**:\n   - Verify full week regeneration still works correctly\n   - Test interaction with other meal plan features\n\n5. **Edge Cases**:\n   - Test with empty meal plans\n   - Test with partially filled meal plans\n   - Test with custom user-added meals",
        "priority": "high",
        "dependencies": [],
        "status": "review",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Make Changes Button to DayView",
            "description": "Update DayView.js to include a 'Make Changes' button in the day header that triggers the conversational workflow for the specific day.",
            "dependencies": [],
            "details": "Implement the button with onClick handler calling handleMakeChanges(day, date, meals). Style it to be visible but non-intrusive using CSS class 'make-changes-btn'. Ensure it appears at the top of each day view.",
            "status": "done",
            "testStrategy": "Unit test button render and click handler. Verify button appears in DayView header and passes correct props to handler.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T00:58:23.647Z"
          },
          {
            "id": 2,
            "title": "Modify regenerateDay Function for Preservation",
            "description": "Update regenerateDay.js to regenerate only the targeted day while preserving all other days in the existing meal plan.",
            "dependencies": [],
            "details": "Fetch current meal plan, generate new content for specific day, find day index, replace only that day's data, then save the updated plan. Ensure no full plan overwrite occurs.",
            "status": "done",
            "testStrategy": "Unit tests: Verify other days unchanged after regeneration; test with various day indices and invalid days; mock getCurrentMealPlan and saveMealPlan.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T00:58:23.648Z"
          },
          {
            "id": 3,
            "title": "Extend ChatWidget for Day-Specific Context",
            "description": "Update ChatWidget.js to accept dayContext prop and initialize conversation with day-specific prompt when opened for changes.",
            "dependencies": [
              1
            ],
            "details": "Add useEffect to set initial assistant message like 'So you want to make changes to ${dayContext.day}'s menu...'. Pass dayContext from DayView button click. Ensure context-aware chat handling.",
            "status": "done",
            "testStrategy": "Unit test: Chat initializes with correct prompt for given dayContext; verify messages array updates on open.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T00:58:23.650Z"
          },
          {
            "id": 4,
            "title": "Update API Endpoint for Partial Updates",
            "description": "Modify api/generate-meal-plan.js to handle day-specific regeneration with preserveOtherDays parameter while supporting full week fallback.",
            "dependencies": [
              2
            ],
            "details": "Parse req.body for day, constraints, preserveOtherDays. Call regenerateSingleDay for single day or generateFullMealPlan otherwise. Return updated plan JSON.",
            "status": "done",
            "testStrategy": "Integration tests: POST requests for single day vs full week; verify response contains preserved days; error handling for invalid inputs.",
            "parentId": "undefined",
            "updatedAt": "2026-01-08T00:58:23.651Z"
          },
          {
            "id": 5,
            "title": "Integrate Full Single-Day Workflow",
            "description": "Connect all components: button click opens ChatWidget with context, chat triggers regenerateDay via API, updates UI with preserved plan.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement handleMakeChanges to open ChatWidget with dayContext. Wire chat responses to call regenerateDay API. Refresh DayView/WeekView after successful update.\n<info added on 2026-01-08T00:58:34.451Z>\nIntegration of the single-day regeneration workflow is complete. The workflow now functions as follows:\n\n1. User clicks \"Make Changes\" button on any day view\n2. ChatWidget opens with contextual message about that specific day\n3. User describes desired changes in natural conversation\n4. Chat stores day context in sessionStorage (regenerate_day, regenerate_date)\n5. When user is ready, they can click \"Generate Week\" which will use existing regenerateDay() function\n6. The regeneration preserves all other days - only selected day is replaced\n7. API endpoint fully supports single-day regeneration with existing meal avoidance\n\nImplementation has been verified:\n- DayView button added and functional\n- Chat opens with proper context\n- regenerateDay.js preserves other 6 days correctly (line 217-218, 301)\n- API endpoint has validation and logic for regenerateDay parameter (lines 114-131, 265-300, 374-391)\n\nFiles modified:\n- src/components/DayView.js (button + openChatForDayChanges method)\n- src/components/ChatWidget.js (dayContext handling + addDayContextMessage method)\n\nReady for end-to-end testing.\n</info added on 2026-01-08T00:58:34.451Z>\n<info added on 2026-01-08T01:32:29.301Z>\nCRITICAL BUG FIX APPLIED after user testing:\n\nUser reported: Week still being deleted during single-day regeneration.\n\nRoot cause identified: GenerationStatusPage.handleComplete() was calling saveMeals(transformed.meals) which REPLACED all meals instead of MERGING with existing ones.\n\nFixes implemented:\n1. Added isSingleDayRegeneration and regeneratingDate tracking in GenerationStatusPage\n2. In handleComplete(), implemented merge strategy:\n   - Load existing meals\n   - Filter out meals for the regenerating date\n   - Merge: [...otherDayMeals, ...newMeals]\n   - Update mealPlan.mealIds to include ALL meals (not just new ones)\n   - Use saveCurrentMealPlan() instead of saveNewMealPlan() to avoid archiving\n3. Made Generate button context-aware:\n   - Shows \"Generate\" when regenerating day\n   - Shows \"Generate Week\" when generating full week\n4. Added same workflow to MealPlanView (week overview cards)\n   - Replaced üîÑ regenerate button with ‚úèÔ∏è make changes button\n   - Uses same conversational workflow\n\nFiles modified:\n- src/components/GenerationStatusPage.js (critical merge logic)\n- src/components/ChatWidget.js (context-aware button text)\n- src/components/MealPlanView.js (added conversational workflow)\n\nReady for critical re-test to verify other days are preserved.\n</info added on 2026-01-08T01:32:29.301Z>",
            "status": "pending",
            "testStrategy": "End-to-end: Click button ‚Üí chat opens with context ‚Üí simulate change request ‚Üí verify only target day updates, others preserved; UI refresh test.",
            "parentId": "undefined"
          }
        ],
        "updatedAt": "2026-01-08T00:58:42.028Z"
      },
      {
        "id": 59,
        "title": "Enhance Meal Plan History Pages",
        "description": "Improve the meal plan history pages by adding AI-generated weekly summaries and restructuring the history detail page with a two-tab interface showing shopping list and weekly overview.",
        "details": "This task involves enhancing the meal plan history pages to provide more value and better organization:\n\n1. **History List Page Improvements** (MealPlanHistoryPage.js):\n- Add AI-generated weekly summaries for each archived meal plan\n- Update the display format to include date range, summary, budget, and meal count\n\n```javascript\n// Example implementation for history list item\nconst MealPlanHistoryItem = ({ mealPlan }) => {\n  return (\n    <div className=\"history-item\">\n      <div className=\"date-range\">{formatDateRange(mealPlan.startDate, mealPlan.endDate)}</div>\n      <div className=\"ai-summary\">{mealPlan.aiSummary || 'No summary available'}</div>\n      <div className=\"budget-summary\">Budget: ${mealPlan.budgetSummary || 'N/A'}</div>\n      <div className=\"meal-count\">Meals: {countMeals(mealPlan)}</div>\n    </div>\n  );\n};\n\n// Function to generate AI summary (could be client or server-side)\nconst generateAISummary = async (mealPlan) => {\n  // Extract key information from meal plan\n  const mealTypes = extractMealTypes(mealPlan);\n  const ingredients = extractCommonIngredients(mealPlan);\n  const specialMeals = findSpecialMeals(mealPlan);\n  \n  // Generate summary using AI service or predefined templates\n  const summary = await aiService.generateSummary({\n    mealTypes,\n    ingredients,\n    specialMeals\n  });\n  \n  return summary;\n};\n```\n\n2. **History Detail Page Restructure** (MealPlanHistoryDetailPage.js):\n- Implement a two-tab interface with Shopping List and Weekly Overview tabs\n- Create day card components showing all meals for the Weekly Overview tab\n- Make meal names clickable links to recipe details\n\n```javascript\n// Example implementation for two-tab interface\nconst MealPlanHistoryDetailPage = ({ mealPlanId }) => {\n  const [activeTab, setActiveTab] = useState('weekly'); // 'weekly' or 'shopping'\n  const [mealPlan, setMealPlan] = useState(null);\n  \n  useEffect(() => {\n    // Fetch complete meal plan data including all 7 days\n    const fetchMealPlan = async () => {\n      const data = await getMealPlanById(mealPlanId);\n      setMealPlan(data);\n    };\n    \n    fetchMealPlan();\n  }, [mealPlanId]);\n  \n  if (!mealPlan) return <Loading />;\n  \n  return (\n    <div className=\"meal-plan-history-detail\">\n      <h1>{formatDateRange(mealPlan.startDate, mealPlan.endDate)}</h1>\n      <p className=\"ai-summary\">{mealPlan.aiSummary}</p>\n      \n      <div className=\"tabs\">\n        <button \n          className={`tab ${activeTab === 'weekly' ? 'active' : ''}`}\n          onClick={() => setActiveTab('weekly')}\n        >\n          Weekly Overview\n        </button>\n        <button \n          className={`tab ${activeTab === 'shopping' ? 'active' : ''}`}\n          onClick={() => setActiveTab('shopping')}\n        >\n          Shopping List\n        </button>\n      </div>\n      \n      <div className=\"tab-content\">\n        {activeTab === 'weekly' ? (\n          <WeeklyOverview days={mealPlan.days} />\n        ) : (\n          <ShoppingList items={mealPlan.shoppingList} />\n        )}\n      </div>\n    </div>\n  );\n};\n\n// Example day card component for Weekly Overview\nconst DayCard = ({ day }) => {\n  return (\n    <div className=\"day-card\">\n      <h3>{day.name}</h3>\n      <p>{formatDate(day.date)}</p>\n      <div className=\"meals\">\n        <div className=\"meal\">\n          <span>Breakfast:</span>\n          <Link to={`/recipe/${day.breakfast.id}`}>{day.breakfast.name}</Link>\n        </div>\n        <div className=\"meal\">\n          <span>Lunch:</span>\n          <Link to={`/recipe/${day.lunch.id}`}>{day.lunch.name}</Link>\n        </div>\n        <div className=\"meal\">\n          <span>Dinner:</span>\n          <Link to={`/recipe/${day.dinner.id}`}>{day.dinner.name}</Link>\n        </div>\n      </div>\n    </div>\n  );\n};\n```\n\n3. **Fix Data Loading**:\n- Update the data fetching logic to include all 7 days, not just one\n- Ensure complete meal data is available for display\n\n```javascript\n// Example data fetching function\nconst getMealPlanById = async (id) => {\n  try {\n    // Fetch complete meal plan with all days\n    const response = await fetch(`/api/meal-plans/${id}?include=all_days`);\n    if (!response.ok) throw new Error('Failed to fetch meal plan');\n    \n    const data = await response.json();\n    \n    // Generate AI summary if not already present\n    if (!data.aiSummary) {\n      data.aiSummary = await generateAISummary(data);\n      // Optionally save the summary back to the database\n      await saveMealPlanSummary(id, data.aiSummary);\n    }\n    \n    return data;\n  } catch (error) {\n    console.error('Error fetching meal plan:', error);\n    throw error;\n  }\n};\n```",
        "testStrategy": "1. **Unit Testing**:\n   - Test AI summary generation function\n   - Test tab switching functionality\n   - Test day card component rendering\n   - Verify shopping list display\n\n2. **Integration Testing**:\n   - Test data fetching and display for both list and detail pages\n   - Verify all 7 days are loaded and displayed correctly\n   - Test navigation between history list and detail pages\n   - Test recipe link navigation\n\n3. **User Acceptance Testing**:\n   - Verify AI summaries are meaningful and accurate\n   - Confirm tab interface is intuitive\n   - Ensure all meal information is visible and accessible\n   - Test shopping list readability\n\n4. **Visual Testing**:\n   - Test responsive design on various screen sizes\n   - Verify tab interface works on mobile devices\n   - Check day card layout on different devices\n\n5. **Performance Testing**:\n   - Test loading times for history pages with many archived meal plans\n   - Measure rendering performance of weekly overview with all days\n   - Test AI summary generation time",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Update History List Page with AI Summaries and New Layout",
            "description": "Modify MealPlanHistoryPage.js to display AI-generated weekly summaries, date range, budget, and meal count for each archived meal plan item.",
            "dependencies": [],
            "details": "Implement MealPlanHistoryItem component as shown in the example code. Add generateAISummary function that extracts meal types, common ingredients, and special meals, then calls aiService.generateSummary. Ensure summary displays even if not pre-generated.",
            "status": "pending",
            "testStrategy": "Unit test MealPlanHistoryItem rendering with mock data including aiSummary; verify display of date range, budget, and meal count; test generateAISummary with various meal plan structures.",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Two-Tab Interface in History Detail Page",
            "description": "Restructure MealPlanHistoryDetailPage.js to include tabs for 'Weekly Overview' and 'Shopping List' with active tab state management.",
            "dependencies": [],
            "details": "Use useState for activeTab ('weekly' or 'shopping'). Create tab buttons with active class styling. Conditionally render WeeklyOverview or ShoppingList components based on activeTab. Display date range header and AI summary.",
            "status": "pending",
            "testStrategy": "Unit test tab switching functionality; verify active class toggles correctly; test conditional rendering of tab content; ensure state persists on re-renders.",
            "parentId": "undefined"
          },
          {
            "id": 3,
            "title": "Create Weekly Overview with Clickable Day Cards",
            "description": "Build WeeklyOverview component featuring DayCard components for each of the 7 days, with clickable meal name links to recipe details.",
            "dependencies": [
              2
            ],
            "details": "Implement DayCard showing day name, date, and meals (breakfast, lunch, dinner) with Link components to /recipe/{id}. Pass days array from mealPlan to WeeklyOverview. Ensure all meals are clickable and properly formatted.",
            "status": "pending",
            "testStrategy": "Unit test DayCard rendering for different days; verify Link hrefs match recipe IDs; test with missing meal data; snapshot test full WeeklyOverview with 7 days.",
            "parentId": "undefined"
          },
          {
            "id": 4,
            "title": "Enhance Data Fetching to Include All 7 Days and Generate Summaries",
            "description": "Update getMealPlanById function to fetch complete meal plan data with all days and generate AI summary if missing.",
            "dependencies": [],
            "details": "Modify API call to include ?include=all_days parameter. Check for aiSummary and generate if absent using generateAISummary, optionally save back to database via saveMealPlanSummary. Handle errors with proper logging.",
            "status": "pending",
            "testStrategy": "Integration test full data fetch with mock API; verify all 7 days returned; test AI summary generation on missing data; test error handling and loading states.",
            "parentId": "undefined"
          },
          {
            "id": 5,
            "title": "Implement Shopping List Tab and Integrate All Components",
            "description": "Create ShoppingList component for the shopping tab and ensure full page integration with loading states and error handling.",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Build ShoppingList component to display mealPlan.shoppingList items. Add Loading component for initial fetch state. Integrate all components in MealPlanHistoryDetailPage with useEffect for data fetching on mount.",
            "status": "pending",
            "testStrategy": "Integration test complete page flow: fetch data, tab switching, day cards, shopping list; end-to-end test from history list click to detail page navigation; verify recipe links work.",
            "parentId": "undefined"
          }
        ]
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-08T00:58:42.028Z",
      "taskCount": 3,
      "completedCount": 1,
      "tags": [
        "master"
      ],
      "created": "2026-01-08T01:32:22.934Z",
      "description": "Tasks for master context"
    }
  }
}