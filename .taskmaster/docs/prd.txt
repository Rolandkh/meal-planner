# Product Requirements Document: Vanessa Chatbot - Meal Planning Assistant

## Project Overview

**Product Name:** Vanessa - AI Meal Planning Concierge
**Version:** v0.8 (Slice 2 Complete)
**Status:** Slices 1 & 2 ‚úÖ Complete | Slice 3 Pending
**Approach:** Vertical Slice ‚Üí Reality Check ‚Üí Expand
**Technology Stack:** Vanilla JavaScript, HTML, CSS (Tailwind), Vercel serverless functions, Claude API

---

## Development Philosophy

This project follows an iterative "vertical slice" approach:

1. **Slice 1**: Build one complete end-to-end flow (chat with Vanessa) ‚úÖ **COMPLETE**
2. **Reality Check**: Evaluate what worked, what was awkward, update spec ‚úÖ **COMPLETE**
3. **Slice 2**: Add meal plan generation flow ‚úÖ **COMPLETE**
4. **Reality Check**: Evaluate and refine ‚úÖ **COMPLETE**
5. **Slice 3+**: Expand features based on learnings
6. **Polish**: UI/UX improvements after core flows are stable

---

## SLICE 1: Chat with Vanessa (MVP Foundation) ‚úÖ COMPLETE

### Goal
Build a working chat interface where users can talk to Vanessa and conversations persist.

### End-to-End Flow
```
1. User opens app
2. User sees simple home page with chat button
3. User opens chat widget
4. User types a message
5. Message sent to /api/chat-with-vanessa
6. Vanessa responds with streaming text (SSE)
7. Response displays in real-time
8. Conversation saved to localStorage
9. On page reload, conversation history is restored
```

### What This Slice Includes

**Frontend Components:**
- `index.html` - App shell with Tailwind CSS
- `HomePage.js` - Simple landing with "Chat with Vanessa" button
- `ChatWidget.js` - Collapsible chat drawer with:
  - Message list (user + assistant messages)
  - Text input + send button
  - Typing indicator during streaming
  - Mobile: full-screen overlay
  - Desktop: side panel

**Backend:**
- `POST /api/chat-with-vanessa` - SSE streaming endpoint
  - Accepts: message, conversation history
  - Returns: Server-Sent Events stream
  - Uses Claude Sonnet API

**Data Storage (localStorage):**
- `conversation` - Array of messages with role, content, timestamp
- `baseSpecification` - Stub user profile (hardcoded for now)

**Utilities:**
- `src/utils/storage.js` - Save/load conversation
- `src/utils/state.js` - App state management
- `src/utils/router.js` - Simple hash-based router (/, /chat)

### What This Slice Does NOT Include
- Normalized data model (eaters, recipes, meals) - Slice 2
- Meal plan generation - Slice 2
- Onboarding flow - Slice 2
- Recipe library - Slice 3
- Usage metering - Slice 3
- Add recipe flow - Slice 4
- Offline mode - Slice 4
- Mobile polish - Final polish phase

### Technical Requirements for Slice 1

**Chat API Endpoint:**
```javascript
// POST /api/chat-with-vanessa
// Request:
{
  message: string,
  chatHistory: [{ role: 'user'|'assistant', content: string }]
}

// Response: Server-Sent Events
data: {"type": "token", "content": "Hi"}
data: {"type": "token", "content": " there!"}
data: {"type": "done"}
```

**Vanessa System Prompt (Slice 1 - Simple):**
```
You are Vanessa, a friendly meal planning assistant. 
Keep responses concise (2-3 sentences).
Help users think about their meal planning needs.
You cannot generate meal plans yet - that feature is coming soon.
```

**localStorage Structure (Slice 1):**
```javascript
{
  'vanessa_conversation': {
    messages: [
      { role: 'assistant', content: 'Hi! I\'m Vanessa...', timestamp: '...' },
      { role: 'user', content: 'Hello!', timestamp: '...' }
    ],
    startedAt: '2025-12-19T...'
  }
}
```

### Success Criteria for Slice 1
- ‚úÖ App loads with home page showing chat button
- ‚úÖ Clicking chat opens the chat widget
- ‚úÖ User can type and send a message
- ‚úÖ Vanessa responds with streaming text
- ‚úÖ Messages display in real-time as they stream
- ‚úÖ Conversation persists after page reload
- ‚úÖ Chat can be closed and reopened
- ‚úÖ Works on mobile (full-screen) and desktop (side panel)
- ‚úÖ Basic error handling (network errors show message)
- ‚úÖ "Generate Week" button always visible in chat
- ‚úÖ Auto-resize textarea as user types

### Known Unknowns (to evaluate after Slice 1)
- Is the streaming UX smooth enough?
- Is the chat widget responsive enough on mobile?
- Are there edge cases with SSE streaming?
- Is the conversation storage approach scalable?
- What patterns should be standardized before Slice 2?

---

## SLICE 2: Meal Plan Generation ‚úÖ COMPLETE

### Goal
Add the ability to generate a complete weekly meal plan with shopping list.

### End-to-End Flow (AS BUILT)
```
1. User chats with Vanessa about preferences (optional)
2. User clicks "‚ú® Generate Week" button (always visible in chat widget)
3. Chat widget closes automatically
4. App navigates to #/generating route
5. GenerationStatusPage displays with animated progress bar
6. SSE stream provides real-time progress updates (10% ‚Üí 25% ‚Üí 50% ‚Üí 75% ‚Üí 90% ‚Üí 95%)
7. Claude generates 7-day meal plan (21 meals: breakfast, lunch, dinner)
8. Response parsed, validated, and transformed to normalized format
9. Data saved to localStorage (recipes, meals, mealPlan)
10. Raw AI output saved to debug_raw_ai_output for debugging
11. Automatic redirect to home page showing meal plan summary
12. On failure: error message with "Retry" and "Start Over" buttons
```

### What This Slice Built

**Components:**
- ‚úÖ `GenerationStatusPage.js` - Full-featured progress UI with SSE streaming, retry logic, error handling
- ‚úÖ `MealPlanView.js` - Complete weekly meal plan display with expandable recipe details
- ‚úÖ `ShoppingListView.js` - Aggregated shopping list grouped by category with metric units
- ‚úÖ `HomePage.js` - Enhanced with meal plan summary cards and navigation buttons

**Backend API:**
- ‚úÖ `POST /api/generate-meal-plan` - Vercel Edge Runtime, SSE streaming
  - Uses Claude Sonnet 4.5 for generation
  - 90-second timeout (Vercel Edge limit)
  - Accepts: `chatHistory` (optional), `eaters` (optional, falls back to default)
  - Returns: SSE stream with progress updates and final meal plan JSON
  - Progress messages: "Analyzing preferences", "Planning week", "Creating recipes", etc.

**Data Transformation & Storage:**
- ‚úÖ `mealPlanTransformer.js` - Transforms Claude's raw JSON to normalized format
  - Recipe deduplication by name + ingredients hash
  - Generates unique IDs (recipe_uuid, meal_uuid, plan_YYYYMMDD)
  - Creates normalized recipes, meals, and mealPlan objects
  - Budget estimation based on recipe complexity
- ‚úÖ `storage.js` - localStorage persistence with quota handling
  - `recipes` - Array of unique Recipe objects
  - `meals` - Array of Meal objects (21 per week)
  - `currentMealPlan` - Active MealPlan object
  - `debug_raw_ai_output` - Raw AI response for debugging
  - Safe save wrapper with QUOTA_EXCEEDED error handling

**Shopping List System:**
- ‚úÖ `ShoppingListView.js` - Comprehensive aggregation system
  - Aggregates all ingredients from all recipes
  - Groups identical ingredients (with fuzzy matching for variations)
  - Converts ALL units to metric (grams/ml) or count (whole items)
  - Deduplicates across recipes
  - Categories: produce, meat, dairy, pantry, other
- ‚úÖ `unitConversions.js` - Extensive conversion mapping
  - 70+ ingredient-specific conversion rules
  - Imperial to metric conversions (cups‚Üíml, oz‚Üíg, lb‚Üíkg)
  - Count items preserved (eggs, onions, tomatoes)
  - Dual display for bread (loaves + slices)
  - Ingredient category classification
  - Fuzzy matching for ingredient variations

**Navigation & Routing:**
- ‚úÖ Updated router with 4 routes:
  - `#/` - HomePage (shows hero or meal plan summary)
  - `#/generating` - GenerationStatusPage (with progress)
  - `#/meal-plan` - MealPlanView (full week view)
  - `#/shopping-list` - ShoppingListView (aggregated list)

**Chat Integration:**
- ‚úÖ "Generate Week" button always visible in ChatWidget
- ‚úÖ Chat history passed to generation API for context
- ‚úÖ Last 10 messages used to inform meal plan preferences
- ‚úÖ System prompt instructs Claude to honor conversation constraints

**Error Handling:**
- ‚úÖ Network errors with user-friendly messages
- ‚úÖ JSON parse errors with fallback extraction
- ‚úÖ Storage quota errors with warnings
- ‚úÖ Retry mechanism on generation failure
- ‚úÖ "Start Over" option returns to home

**UI/UX Enhancements:**
- ‚úÖ Gradient backgrounds for different sections
- ‚úÖ Animated progress bar with emoji (üç≥)
- ‚úÖ Collapsible recipe details in meal plan
- ‚úÖ Checkboxes on shopping list (visual only, not functional yet)
- ‚úÖ Responsive design (mobile + desktop)
- ‚úÖ Loading states and disabled buttons during operations
- ‚úÖ Success/error feedback messages
- ‚úÖ Export raw AI output button for debugging

### Data Model (AS IMPLEMENTED)

**Recipe Object:**
```javascript
{
  recipeId: 'recipe_[uuid]',
  name: 'Recipe Name',
  ingredients: [
    {
      name: 'ingredient name',
      quantity: number,
      unit: 'g' | 'ml' | 'whole' | etc.,
      category: 'produce' | 'meat' | 'dairy' | 'pantry' | 'other'
    }
  ],
  instructions: 'Brief instructions (2-3 sentences max)',
  prepTime: number,        // minutes
  cookTime: number,        // minutes
  servings: number,
  tags: ['tag1', 'tag2'],
  source: 'generated',
  rating: null,
  createdAt: 'ISO 8601 timestamp'
}
```

**Meal Object:**
```javascript
{
  mealId: 'meal_[uuid]',
  recipeId: 'recipe_[uuid]',
  mealType: 'breakfast' | 'lunch' | 'dinner',
  date: 'YYYY-MM-DD',
  eaterIds: [],            // Empty for now, used in Slice 3
  servings: number,
  notes: ''
}
```

**MealPlan Object:**
```javascript
{
  _schemaVersion: 1,
  mealPlanId: 'plan_YYYYMMDD',
  weekOf: 'YYYY-MM-DD',    // Saturday start
  weekEnd: 'YYYY-MM-DD',   // Friday end
  createdAt: 'ISO 8601 timestamp',
  mealIds: ['meal_uuid1', 'meal_uuid2', ...],  // 21 meals
  budget: {
    target: 0,             // Not used yet
    estimated: number      // Calculated from recipes
  },
  weeklyPreferences: '',   // Empty for now
  conversation: {
    messages: []           // Empty for now, used in Slice 3
  }
}
```

### System Prompt (Meal Plan Generation)
```
You are Vanessa, an expert meal planning assistant. Generate a complete 7-day meal plan.

CRITICAL: Your response must be ONLY valid JSON in this EXACT format with NO additional text.

Guidelines:
- Generate exactly 7 days of meals (21 total: breakfast, lunch, dinner each day)
- Keep instructions BRIEF (2-3 sentences max per recipe)
- Include realistic estimated budget in dollars
- Consider user's dietary preferences and restrictions
- Vary recipes throughout the week
- Use 3-6 main ingredients per recipe (keep it simple)
- Focus on practical, quick recipes

CRITICAL - Units:
- Use ONLY metric units in ingredient quantities
- Liquids: milliliters (ml) or liters
- Solids: grams (g) or kilograms (kg)
- DO NOT use: ounces, pounds, cups, tablespoons, teaspoons
- Exception: Count items can use "whole" (e.g., "2 whole onions")
```

### What This Slice Does NOT Include (Deferred)
- Full onboarding flow (hardcoded default eater used)
- Eaters management UI
- Recipe library browsing
- Recipe favorites/ratings (data structure exists, UI pending)
- Usage metering/limits
- Edit/modify meal plan
- Regenerate single day
- Shopping list check-off persistence
- Export meal plan to PDF/markdown (debug export only)

---

## REALITY CHECK: Slice 2 Learnings

### What Worked Well ‚úÖ

1. **SSE Streaming for Progress**
   - Real-time progress updates provide excellent UX
   - Users see what's happening during 30-60 second generation
   - Pattern works well, should be reused for long operations

2. **Data Transformation Layer**
   - Clean separation between Claude's output and our storage format
   - Recipe deduplication works perfectly (hash-based on name + ingredients)
   - Easy to add validation and error handling in one place

3. **localStorage Strategy**
   - Simple, fast, no backend needed
   - Quota handling prevents silent failures
   - Debug output saved separately is invaluable for troubleshooting

4. **Unit Conversion System**
   - Comprehensive mapping handles 70+ ingredients
   - Metric-only shopping lists are clearer for Australian users
   - Fuzzy matching for ingredient variations works well

5. **Chat Context Integration**
   - Last 10 chat messages provide excellent context to Claude
   - Users can specify constraints ("30 ingredients max") and they work
   - No need for separate preference forms (yet)

6. **Component Lifecycle Hooks**
   - `afterRender()` hook perfect for triggering async operations
   - `beforeUnload()` for cleanup works well
   - Router's component pattern is flexible and simple

### What Was Awkward / Could Improve ü§î

1. **Shopping List Aggregation Complexity**
   - The aggregation logic is quite complex (300+ lines)
   - Multiple passes needed: collect ‚Üí aggregate ‚Üí convert ‚Üí dedupe
   - Hard to debug when ingredients don't combine as expected
   - **Learning**: Consider pre-processing ingredient names during generation

2. **Metric-Only Requirement**
   - System prompt says "metric only" but Claude sometimes forgets
   - We have fallback conversion, but adds complexity
   - **Learning**: May need stricter validation or retry logic

3. **Storage Keys Mix**
   - Some keys namespaced (`vanessa-chat-history`), some not (`recipes`, `eaters`)
   - Inconsistent naming convention
   - **Learning**: Standardize on `vanessa_` prefix for all keys in Slice 3

4. **No Eater Management Yet**
   - Hardcoded default eater works, but feels incomplete
   - Users can't specify household members yet
   - **Learning**: Slice 3 should add eater management before recipe library

5. **Error Messages Could Be Better**
   - Some errors just say "Generation failed"
   - No guidance on what to do (check internet? try again? contact support?)
   - **Learning**: Add more specific error types with actionable messages

6. **No Way to Modify Generated Plan**
   - If user doesn't like one recipe, they must regenerate entire week
   - **Learning**: Slice 3 or 4 should add "regenerate day" or "swap recipe" feature

### Technical Discoveries üîç

1. **Vercel Edge Runtime Limits**
   - 90-second timeout is hard limit
   - 8192 max_tokens usually sufficient for 7-day plan
   - Lower temperature (0.7) produces faster, more focused output

2. **Claude Sonnet 4.5 Performance**
   - Excellent at following JSON structure requirements
   - Occasionally adds markdown code fences (we strip them)
   - Honors conversation context very well
   - Budget estimates are reasonable but not accurate

3. **localStorage Quota**
   - ~5MB limit sufficient for multiple weeks
   - One week = ~50-100KB (recipes + meals + plan)
   - Could store 20-30 weeks before hitting quota
   - Debug output can fill quickly if not pruned

4. **Recipe Deduplication**
   - Hash-based approach works perfectly
   - Same recipe across multiple days correctly shares one Recipe object
   - Saves significant storage space

### Architecture Patterns Established üìê

1. **Data Flow:**
   ```
   User Intent ‚Üí Chat Widget ‚Üí API Endpoint ‚Üí Claude API
                                   ‚Üì
   Raw JSON ‚Üí Transformer ‚Üí Normalized Data ‚Üí localStorage
                                   ‚Üì
                          View Components ‚Üí Display
   ```

2. **Component Pattern:**
   - Each page is a class with `render()` method
   - Optional lifecycle hooks: `beforeRender()`, `afterRender()`, `beforeUnload()`
   - Components return HTMLElement or string
   - Router manages mounting/unmounting

3. **Error Handling:**
   - Try/catch at every async boundary
   - `ErrorHandler` utility for consistent messaging
   - Graceful degradation (show error, offer retry)
   - Log errors to console for debugging

4. **Storage Pattern:**
   - `load*()` functions return data or default (never throw)
   - `save*()` functions return result object with success/error
   - Validation happens before save
   - Atomic saves (all or nothing)

### Decisions Made üìù

1. **Week Start = Saturday**
   - Aligns with shopping day (Saturday morning)
   - Plan covers Sat ‚Üí Fri (7 days)
   - Hardcoded for now, could be user preference later

2. **Metric Units Only**
   - Australian market preference
   - Simpler for shopping (no cups/tbsp)
   - All conversions go one direction (imperial ‚Üí metric)

3. **No Database Yet**
   - localStorage sufficient for Phase 1
   - Defer Firebase/backend until usage metering needed (Slice 4)
   - Keeps deployment simple (static site)

4. **Chat History Context Limit**
   - Last 10 messages passed to generation
   - Enough for recent context, not too much tokens
   - Prevents prompt bloat

5. **Debug Output Saved**
   - Raw AI output saved to `debug_raw_ai_output`
   - Single key (overwrites each generation)
   - Export button on home page for debugging

### Ready for Slice 3? ‚úÖ

**Prerequisites Met:**
- ‚úÖ Core generation flow works end-to-end
- ‚úÖ Data model is stable and proven
- ‚úÖ Storage layer is robust
- ‚úÖ UI patterns established

**What Slice 3 Needs:**
1. Eater management (add/edit household members)
2. Preference settings (dietary restrictions, allergies)
3. Recipe library view (browse saved recipes)
4. Recipe detail view with favorites/ratings
5. Conversation history saved to meal plan
6. Standardize storage keys

**Blockers:** None. Ready to proceed.

---

## SLICE 3: Eaters, Profile & Recipe Library

### Goal
Add household member management, user profile system, and recipe browsing capabilities.

### End-to-End Flow (PLANNED)
```
FLOW A: First-Time User Onboarding
1. User opens app (no profile exists)
2. Sees welcome message: "Chat with Vanessa to get started"
3. Opens chat widget
4. Vanessa asks 5-6 essential onboarding questions:
   - Dietary goals/restrictions
   - Household members (eaters)
   - Weekly budget
   - Shopping day
5. Profile auto-saves as conversation progresses
6. After final question: "You're all set! Click Generate Week when ready."
7. User can now generate meal plans

FLOW B: Eater Management
1. User navigates to #/settings
2. Sees "Household" section with list of eaters
3. Clicks "+ Add Member" button
4. Fills form: name, preferences, schedule, allergies
5. Saves ‚Üí new eater added to household
6. Can edit/delete existing eaters
7. Future meal plans consider all household members

FLOW C: Recipe Library
1. User navigates to #/recipes (new nav link)
2. Sees grid of all saved recipes
3. Can search by name/ingredient
4. Can filter: All / Favorites / High-Rated / Most Cooked
5. Clicks recipe card ‚Üí navigates to recipe detail
6. In detail view: see full recipe, toggle favorite, rate 1-5 stars
7. Back button returns to library

FLOW D: Profile Editing
1. User navigates to #/settings
2. Sees sections: Household, Meal Planning, Chat Preferences
3. Can edit: weekly budget, shopping day, dietary goals
4. Changes save immediately (or with Save button)
5. Success toast: "Profile updated"
```

### What This Slice Builds

**New Pages/Components:**
- ‚úÖ `SettingsPage.js` - Unified settings/profile page
  - Household section with eater CRUD
  - Meal planning preferences (budget, shopping day)
  - Chat preferences (personality, communication style)
- ‚úÖ `RecipeLibraryPage.js` - Browse saved recipes
  - Search bar (searches name, ingredients, tags)
  - Filter dropdown (All, Favorites, High-Rated, Most Cooked)
  - Recipe grid with cards
  - Recipe count display
- ‚úÖ `RecipeDetailPage.js` - Individual recipe view
  - Full recipe display
  - Star rating system (1-5 stars, clickable)
  - Favorite toggle button
  - Usage stats (times cooked, last cooked)
  - Servings, prep/cook time
  - Back button to library

**New Data Entities:**
- ‚úÖ `Eater` - Household member
  ```javascript
  {
    eaterId: 'eater_[uuid]',
    name: string,
    preferences: string,
    allergies: string[],
    dietaryRestrictions: string[],
    schedule: string,
    isDefault: boolean,
    createdAt: 'ISO 8601',
    updatedAt: 'ISO 8601'
  }
  ```

- ‚úÖ `BaseSpecification` - User profile
  ```javascript
  {
    _schemaVersion: 1,
    ownerEaterId: 'eater_[uuid]',
    weeklyBudget: number,
    shoppingDay: 0-6,  // 0=Sunday, 6=Saturday
    preferredStore: string,
    householdEaterIds: ['eater_[uuid]', ...],
    dietaryGoals: string,
    onboardingComplete: boolean,
    conversation: {
      startedAt: 'ISO 8601',
      messages: [{role, content, timestamp}]
    },
    createdAt: 'ISO 8601',
    updatedAt: 'ISO 8601'
  }
  ```

**Enhanced Existing Entities:**
- ‚úÖ Update `Recipe` with rating/favorite fields (already in data model, now add UI)
  - `isFavorite: boolean` - Toggle in recipe detail
  - `rating: number | null` - 1-5 star rating
  - `timesCooked: number` - Auto-increment when meal plan used
  - `lastCooked: 'ISO 8601' | null` - Track last usage

**Chat Integration:**
- ‚úÖ Onboarding conversation flow
  - Vanessa asks 5-6 questions on first visit
  - Stores responses in BaseSpecification
  - Marks onboardingComplete when done
- ‚úÖ Profile update conversations
  - User: "I want to change my budget to $200"
  - Vanessa: "I'll update your budget to $200. Confirm?"
  - User: "Yes"
  - Vanessa updates baseSpecification.weeklyBudget

**Storage Updates:**
- ‚úÖ **Standardize localStorage keys** (fix inconsistency from Slice 2):
  - `vanessa_chat_history` (already has prefix)
  - `vanessa_recipes` (rename from `recipes`)
  - `vanessa_meals` (rename from `meals`)
  - `vanessa_current_meal_plan` (rename from `currentMealPlan`)
  - `vanessa_eaters` (new)
  - `vanessa_base_specification` (new)
  - `vanessa_debug_raw_output` (rename from `debug_raw_ai_output`)

- ‚úÖ **Add storage utilities** (new functions in `storage.js`):
  ```javascript
  // Quota monitoring
  getStorageQuota() ‚Üí { used, limit, percentUsed, remaining, warning }
  
  // Export/Import
  exportAllData() ‚Üí downloads JSON file
  importAllData(file) ‚Üí restores from JSON
  
  // Cleanup
  clearOldMealPlans(keepWeeks=4) ‚Üí removes old data
  deleteOrphanedRecipes() ‚Üí removes unused recipes
  ```

- ‚úÖ **Add UI for storage management** (in Settings page):
  - Storage stats display (X MB / 5 MB used)
  - Warning banner when >80% full
  - Export button (download backup)
  - Import button (restore from file)
  - Cleanup button (clear old weeks)

**Navigation Updates:**
- ‚úÖ Add nav links (in header or sidebar):
  - Home (#/)
  - Recipes (#/recipes) - NEW
  - Shopping List (#/shopping-list)
  - Settings (#/settings) - NEW
- ‚úÖ Add routes:
  - `#/recipes` ‚Üí RecipeLibraryPage
  - `#/recipe/:id` ‚Üí RecipeDetailPage
  - `#/settings` ‚Üí SettingsPage

**Generation Updates:**
- ‚úÖ Pass eaters to generation API
  - Load eaters from storage
  - Include in POST body: `{chatHistory, eaters: [...]}`
  - Claude considers all household members
- ‚úÖ Save conversation with meal plan
  - Store last 10 chat messages in mealPlan.conversation

**Vanessa System Prompt Updates:**
- ‚úÖ Include base specification context
- ‚úÖ Include eater information
- ‚úÖ Include recipe library stats
- ‚úÖ Profile update confirmation flow

### Onboarding Flow Specification

**First Visit Detection:**
```javascript
// On app load
const baseSpec = loadBaseSpecification();
if (!baseSpec || !baseSpec.onboardingComplete) {
  // Show onboarding state
  chatWidget.open();
  chatWidget.showWelcomeMessage();
}
```

**Onboarding Questions (Vanessa asks):**
1. **Dietary Goals**
   - "What are your main dietary goals? (e.g., lose weight, eat healthier, follow a specific diet)"
   - Store in: `baseSpec.dietaryGoals`

2. **Food Restrictions**
   - "Are there any foods you don't eat or want to avoid?"
   - Create owner eater, store in: `eater.preferences`

3. **Household Members**
   - "Do you cook for anyone else, like family members with different preferences?"
   - If yes: "Tell me about them (names, ages, preferences)"
   - Create additional eaters

4. **Weekly Budget**
   - "What's your weekly grocery budget?"
   - Store in: `baseSpec.weeklyBudget`

5. **Shopping Day**
   - "Which day do you usually do your grocery shopping?"
   - Store in: `baseSpec.shoppingDay` (0-6)

6. **Confirmation**
   - "Perfect! You're all set. Click Generate Week whenever you're ready to create your first meal plan."
   - Set: `baseSpec.onboardingComplete = true`

**Progressive Enhancement (Future):**
- After first meal plan, Vanessa can ask optional questions:
  - Preferred grocery store
  - Eating window (intermittent fasting)
  - Cooking skill level
  - Time available for cooking

### Recipe Library Features

**Search Functionality:**
- Real-time search (debounced 300ms)
- Searches: recipe name, ingredients, tags
- Case-insensitive
- Highlights matches (future enhancement)

**Filter Options:**
```javascript
const filters = {
  'all': (recipe) => true,
  'favorites': (recipe) => recipe.isFavorite === true,
  'high-rated': (recipe) => recipe.rating >= 4,
  'most-cooked': (recipe) => recipe.timesCooked >= 3
};
```

**Sort Order:**
- Default: Most cooked first (descending)
- Then: Alphabetical by name

**Recipe Card Display:**
```javascript
{
  recipeImage: 'üçΩÔ∏è', // Emoji placeholder
  recipeName: string,
  cookTime: number + ' min',
  servings: number + ' servings',
  rating: '‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ' (1-5 stars),
  favoriteIndicator: '‚ù§Ô∏è' if isFavorite,
  timesCooked: 'Cooked X times'
}
```

**Empty States:**
- No recipes yet: "No recipes in your library yet. Generate a meal plan to add recipes!"
- No search results: "No recipes match '{query}'. Try a different search."
- No favorites: "You haven't favorited any recipes yet."

### Recipe Detail Features

**Display Sections:**
1. **Header**
   - Recipe name (large)
   - Favorite toggle button (heart icon)
   - Star rating (clickable stars)
   - Back button

2. **Meta Info**
   - Prep time, cook time, total time
   - Servings
   - Source (generated/user/imported)
   - Times cooked, last cooked

3. **Ingredients**
   - Grouped by category (produce, meat, dairy, pantry)
   - Quantity + unit + name
   - Checkbox (for shopping list, future)

4. **Instructions**
   - Step-by-step
   - Numbered list
   - Clear, concise

5. **Tags**
   - Clickable tag chips
   - Example: "quick", "healthy", "vegetarian"

6. **Usage History** (future)
   - "Used in meal plans: [dates]"

**Interactions:**
- Click star ‚Üí Update rating, save to storage, re-render
- Click heart ‚Üí Toggle favorite, save to storage, re-render
- Click back ‚Üí Navigate to #/recipes

### Storage Management Features (New in Slice 3)

**Storage Quota Monitoring:**
```javascript
// Add to storage.js
export function getStorageQuota() {
  let totalBytes = 0;
  
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    const value = localStorage.getItem(key);
    totalBytes += (key.length + value.length) * 2; // UTF-16 = 2 bytes per char
  }
  
  const limitBytes = 5 * 1024 * 1024; // 5MB
  const percentUsed = (totalBytes / limitBytes) * 100;
  
  return {
    usedBytes: totalBytes,
    usedMB: (totalBytes / 1024 / 1024).toFixed(2),
    limitMB: 5,
    percentUsed: percentUsed.toFixed(1),
    remainingMB: ((limitBytes - totalBytes) / 1024 / 1024).toFixed(2),
    warning: percentUsed > 80 ? 'critical' : percentUsed > 60 ? 'warning' : 'ok'
  };
}
```

**Export All Data:**
```javascript
export function exportAllData() {
  const data = {
    _exportVersion: 1,
    exportedAt: new Date().toISOString(),
    appVersion: '0.8',
    data: {
      chatHistory: loadChatHistory(),
      eaters: loadEaters(),
      recipes: loadRecipes(),
      meals: loadMeals(),
      currentMealPlan: loadCurrentMealPlan(),
      baseSpecification: loadBaseSpecification()
    }
  };
  
  const json = JSON.stringify(data, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `vanessa-backup-${new Date().toISOString().split('T')[0]}.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  return { success: true, size: json.length };
}
```

**Import Data:**
```javascript
export async function importAllData(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      try {
        const imported = JSON.parse(e.target.result);
        
        // Validate version
        if (imported._exportVersion !== 1) {
          throw new Error('Incompatible backup version');
        }
        
        // Restore all data
        const data = imported.data;
        saveChatHistory(data.chatHistory || []);
        saveEaters(data.eaters || []);
        saveRecipes(data.recipes || []);
        saveMeals(data.meals || []);
        saveCurrentMealPlan(data.currentMealPlan);
        saveBaseSpecification(data.baseSpecification);
        
        resolve({ 
          success: true, 
          imported: Object.keys(data).length,
          exportedAt: imported.exportedAt 
        });
      } catch (error) {
        reject({ success: false, error: error.message });
      }
    };
    
    reader.onerror = () => reject({ success: false, error: 'File read error' });
    reader.readAsText(file);
  });
}
```

**Clear Old Data:**
```javascript
export function clearOldMealPlans(keepMostRecent = 4) {
  // TODO: When we support multiple meal plans in Slice 4
  // For now, just provide interface
  return {
    success: true,
    cleared: 0,
    kept: 1,
    spaceSaved: 0
  };
}

export function deleteOrphanedRecipes() {
  const recipes = loadRecipes();
  const meals = loadMeals();
  
  // Get all recipe IDs currently in use
  const usedRecipeIds = new Set(meals.map(m => m.recipeId));
  
  // Find orphaned recipes
  const orphaned = recipes.filter(r => !usedRecipeIds.has(r.recipeId));
  
  if (orphaned.length === 0) {
    return { success: true, deleted: 0, remaining: recipes.length };
  }
  
  // Keep only used recipes
  const remaining = recipes.filter(r => usedRecipeIds.has(r.recipeId));
  const result = saveRecipes(remaining);
  
  return {
    success: result.success,
    deleted: orphaned.length,
    remaining: remaining.length,
    orphanedNames: orphaned.map(r => r.name)
  };
}
```

**UI Components:**
- Storage stats card in Settings page
- Warning banner when >80% full
- Export/Import buttons
- Cleanup button with confirmation dialog

### Settings Page Features

**Layout:**
Four sections (tabs or accordion):

**1. Storage Section** (NEW)
- **Storage Stats Card:**
  - Progress bar showing X MB / 5 MB used
  - Percentage indicator
  - Color coding: green (<60%), yellow (60-80%), red (>80%)
  
- **Backup & Restore:**
  - Export button: "Download Backup" ‚Üí saves JSON file
  - Import button: "Restore from Backup" ‚Üí file picker
  - Last backup date display
  
- **Data Cleanup:**
  - "Delete Old Meal Plans" button
    - Dropdown: Keep last [4] weeks
    - Shows: "Will delete X weeks, save Y MB"
  - "Remove Unused Recipes" button
    - Shows: "X orphaned recipes found"
  - Confirmation dialogs before deletion

**2. Household Section**
- **Owner Eater**
  - Name (editable)
  - Dietary goals/preferences
  - Edit button

- **Other Members**
  - List of household members
  - Each shows: name, preferences summary
  - Edit / Delete buttons
  - "+ Add Member" button

- **Add/Edit Eater Modal/Form:**
  ```javascript
  {
    name: string (required),
    preferences: string (textarea),
    allergies: string[] (tags or comma-separated),
    dietaryRestrictions: string[] (tags or comma-separated),
    schedule: string (textarea),
    isDefault: boolean (checkbox for owner)
  }
  ```

**3. Meal Planning Section**
- Weekly budget (number input with $ prefix)
- Shopping day (dropdown: Sunday-Saturday)
- Preferred store (text input, optional)
- Dietary goals (textarea)

**4. Chat Preferences Section** (optional for Slice 3)
- Vanessa personality: Friendly, Professional, Casual
- Communication style: Concise, Detailed
- Reset onboarding button (re-triggers questions)

**Save Behavior:**
- Auto-save on blur for most fields
- Immediate save for storage operations (export, import, cleanup)
- Success toast: "Settings saved ‚úì"
- Error toast: "Save failed. Please try again."

**Save Behavior:**
- Auto-save on blur (for text inputs)
- OR single "Save Changes" button at bottom
- Success toast: "Settings saved ‚úì"

### Data Migration

**From Slice 2 to Slice 3:**
```javascript
// Run on first load of Slice 3
function migrateToSlice3() {
  // 1. Rename storage keys
  renameKey('recipes', 'vanessa_recipes');
  renameKey('meals', 'vanessa_meals');
  renameKey('currentMealPlan', 'vanessa_current_meal_plan');
  renameKey('debug_raw_ai_output', 'vanessa_debug_raw_output');
  
  // 2. Create default eater if none exists
  if (!loadEaters().length) {
    const defaultEater = {
      eaterId: 'eater_' + crypto.randomUUID(),
      name: 'User',
      preferences: 'no restrictions',
      allergies: [],
      dietaryRestrictions: [],
      schedule: 'home for dinner',
      isDefault: true,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    saveEaters([defaultEater]);
  }
  
  // 3. Create base specification if none exists
  if (!loadBaseSpecification()) {
    const eaters = loadEaters();
    const ownerEater = eaters.find(e => e.isDefault) || eaters[0];
    
    const baseSpec = {
      _schemaVersion: 1,
      ownerEaterId: ownerEater.eaterId,
      weeklyBudget: 150,
      shoppingDay: 6, // Saturday
      preferredStore: '',
      householdEaterIds: eaters.map(e => e.eaterId),
      dietaryGoals: '',
      onboardingComplete: false, // Will trigger onboarding
      conversation: {
        startedAt: new Date().toISOString(),
        messages: []
      },
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    saveBaseSpecification(baseSpec);
  }
  
  // 4. Add rating/favorite fields to existing recipes
  const recipes = loadRecipes();
  const updated = recipes.map(r => ({
    ...r,
    isFavorite: r.isFavorite ?? false,
    rating: r.rating ?? null,
    timesCooked: r.timesCooked ?? 0,
    lastCooked: r.lastCooked ?? null
  }));
  saveRecipes(updated);
  
  // 5. Set migration flag
  localStorage.setItem('vanessa_migration_slice3', 'complete');
}
```

**Storage Enhancements (localStorage + Features):**
- ‚úÖ **Storage Quota Monitoring**
  - Track localStorage usage (bytes used / 5MB limit)
  - Show warning banner at 80% capacity
  - Display storage stats in settings
  
- ‚úÖ **Export/Import Functionality**
  - Export all data to JSON file (complete backup)
  - Import from JSON file (restore data)
  - Download format: `vanessa-backup-YYYY-MM-DD.json`
  
- ‚úÖ **Data Cleanup Features**
  - Clear old meal plans (keep last 4 weeks)
  - Delete unused recipes (not in any meal plan)
  - Manual cleanup UI in settings
  - Show space saved after cleanup

**Storage Architecture Decision:**
- Continue with localStorage for Slice 3
- Quota: 5MB = ~20-30 weeks of data (sufficient)
- Migration to Firebase deferred to Slice 4 (when usage metering added)
- Storage abstraction layer makes future migration easy (1-2 days work)

### What This Slice Does NOT Include (Deferred to Slice 4+)

- ‚ùå Recipe import from URL
- ‚ùå Recipe import from pasted text
- ‚ùå Manual recipe creation form
- ‚ùå Usage metering / server-side limits
- ‚ùå Firebase/database migration
- ‚ùå Multi-device sync
- ‚ùå User authentication
- ‚ùå Upgrade prompts
- ‚ùå Pantry system
- ‚ùå Recipe editing after creation
- ‚ùå Meal plan history UI (data stored, no UI yet)
- ‚ùå Regenerate single day
- ‚ùå Export to PDF/calendar
- ‚ùå Advanced offline mode features

---

## SLICE 4: Recipe Import & Firebase Migration

### Goal
Add recipe import capabilities and migrate to Firebase for multi-device sync and usage metering.

### What This Slice Adds

**Recipe Import:**
- Add recipe from pasted text (Claude extracts structure)
- Add recipe from URL (fetch + Claude extraction)
- Manual recipe creation form
- Recipe editing after creation

**Database Migration:**
- Migrate from localStorage to Firebase Firestore
- Add Firebase Authentication (anonymous + Google)
- Multi-device sync (same account on phone + desktop)
- Automatic cloud backup
- Server-side usage tracking

**Usage Metering:**
- Track generations per month (server-side in Firebase)
- Track messages per month
- Free tier limits (4 generations/month, 100 messages/month)
- Upgrade prompts for exceeded limits
- Pro tier option ($5-10/month for unlimited)

**Polish & Enhancements:**
- Mobile responsiveness improvements
- Advanced error handling
- Performance optimizations
- Meal plan history UI (browse past weeks)
- Regenerate single day feature

---

## Core Entities (As Implemented)

### Slice 1 Entities ‚úÖ
```javascript
// Conversation (chat history in localStorage)
// Key: 'vanessa-chat-history'
[
  {
    role: 'user' | 'assistant',
    content: string,
    timestamp: 'ISO 8601'
  }
]
```

### Slice 2 Entities ‚úÖ
```javascript
// Recipe (stored in 'recipes' key)
{
  recipeId: 'recipe_[uuid]',
  name: string,
  ingredients: [
    {
      name: string,
      quantity: number,
      unit: string,
      category: 'produce' | 'meat' | 'dairy' | 'pantry' | 'other'
    }
  ],
  instructions: string,
  prepTime: number,
  cookTime: number,
  servings: number,
  tags: string[],
  source: 'generated' | 'user' | 'imported',
  rating: number | null,
  createdAt: 'ISO 8601'
}

// Meal (stored in 'meals' key)
{
  mealId: 'meal_[uuid]',
  recipeId: 'recipe_[uuid]',
  mealType: 'breakfast' | 'lunch' | 'dinner',
  date: 'YYYY-MM-DD',
  eaterIds: string[],
  servings: number,
  notes: string
}

// MealPlan (stored in 'currentMealPlan' key)
{
  _schemaVersion: 1,
  mealPlanId: 'plan_YYYYMMDD',
  weekOf: 'YYYY-MM-DD',
  weekEnd: 'YYYY-MM-DD',
  createdAt: 'ISO 8601',
  mealIds: string[],
  budget: {
    target: number,
    estimated: number
  },
  weeklyPreferences: string,
  conversation: {
    messages: any[]
  }
}

// Debug Output (stored in 'debug_raw_ai_output' key)
{
  timestamp: 'ISO 8601',
  rawData: object  // Claude's raw JSON response
}
```

### Slice 3 Entities (To Be Implemented)
```javascript
// Eater (stored in 'eaters' key)
{
  eaterId: 'eater_[uuid]',
  name: string,
  preferences: string,
  allergies: string[],
  dietaryRestrictions: string[],
  schedule: string,
  isDefault: boolean
}

// BaseSpecification (stored in 'baseSpecification' key)
{
  ownerName: string,
  weeklyBudget: number,
  shoppingDay: 0-6,  // 0=Sunday, 6=Saturday
  currency: 'AUD',
  preferredStores: string[],
  householdSize: number
}

// UsageLimits (stored in 'usageLimits' key)
{
  plansGenerated: number,
  plansLimit: number,
  lastReset: 'ISO 8601',
  tier: 'free' | 'paid'
}
```

---

## High-Level Page List

| Page | Route | Slice | Status | Description |
|------|-------|-------|--------|-------------|
| Home | `#/` | 1 | ‚úÖ | Landing with chat button OR meal plan summary |
| Chat (widget) | n/a | 1 | ‚úÖ | Collapsible chat drawer (always available) |
| Generation Status | `#/generating` | 2 | ‚úÖ | Progress UI during generation with SSE updates |
| Meal Plan View | `#/meal-plan` | 2 | ‚úÖ | Full week view with all meals and recipes |
| Shopping List | `#/shopping-list` | 2 | ‚úÖ | Aggregated shopping list grouped by category |
| Recipe Library | `#/recipes` | 3 | üìù | Browse/search saved recipes |
| Recipe Detail | `#/recipe/:id` | 3 | üìù | Full recipe view with ratings |
| Eater Management | `#/eaters` | 3 | üìù | Manage household members |
| Settings | `#/settings` | 3 | üìù | User preferences and settings |
| Add Recipe | `#/add-recipe` | 4 | üìù | Import recipe flow |

---

## Critical Happy Paths

### Slice 1: Chat Flow
1. Open app ‚Üí See home page
2. Click "Chat with Vanessa" ‚Üí Chat opens
3. Type message ‚Üí Send
4. See streaming response ‚Üí Message complete
5. Close chat ‚Üí Reopen ‚Üí History preserved

### Slice 2: Generation Flow
1. Open chat ‚Üí Discuss preferences (optional)
2. Click Generate ‚Üí Navigate to status page
3. See progress bar ‚Üí Wait for completion
4. Success ‚Üí See meal plan
5. (If fail) ‚Üí Auto-retry ‚Üí (If fail again) ‚Üí Show options

---

## API Endpoints

| Endpoint | Slice | Status | Method | Runtime | Purpose |
|----------|-------|--------|--------|---------|---------|
| `/api/chat-with-vanessa` | 1 | ‚úÖ | POST | Edge | SSE streaming chat with Claude Sonnet 4.5 |
| `/api/generate-meal-plan` | 2 | ‚úÖ | POST | Edge | Generate 7-day meal plan with progress updates |
| `/api/extract-recipe` | 4 | üìù | POST | Edge | Extract recipe from URL or text |
| `/api/check-env` | - | ‚úÖ | GET | Edge | Development endpoint to verify API key |
| `/api/test-models` | - | ‚úÖ | GET | Edge | Development endpoint to test Claude models |

### API Details

#### POST /api/chat-with-vanessa
**Request:**
```json
{
  "message": "string (required)",
  "chatHistory": [
    {
      "role": "user | assistant",
      "content": "string"
    }
  ]
}
```

**Response:** SSE stream
```
data: {"type": "token", "content": "text"}
data: {"type": "token", "content": "more text"}
data: {"type": "done"}
```

**Errors:**
```
data: {"type": "error", "error": "Error message", "details": "..."}
```

**Configuration:**
- Model: `claude-sonnet-4-5-20250929`
- Max tokens: 1000
- Temperature: 0.7
- Timeout: 30 seconds
- System prompt: Concise, friendly meal planning assistant

#### POST /api/generate-meal-plan
**Request:**
```json
{
  "chatHistory": [
    {
      "role": "user | assistant",
      "content": "string"
    }
  ],
  "eaters": [
    {
      "name": "string",
      "preferences": "string",
      "schedule": "string"
    }
  ]
}
```

**Response:** SSE stream
```
data: {"type": "progress", "progress": 10, "message": "Analyzing preferences..."}
data: {"type": "progress", "progress": 25, "message": "Planning your week..."}
...
data: {"type": "complete", "data": { /* meal plan JSON */ }}
```

**Errors:**
```
data: {"type": "error", "error": "Error message"}
```

**Configuration:**
- Model: `claude-sonnet-4-5-20250929`
- Max tokens: 8192
- Temperature: 0.7
- Timeout: 90 seconds
- System prompt: Detailed meal plan generation with JSON output
- Returns: 7 days √ó 3 meals = 21 recipes with ingredients

---

## Tech Stack (Confirmed)

- **Frontend**: Vanilla JS (ES6 modules), HTML5, Tailwind CSS (CDN)
- **Backend**: Vercel Edge Functions (serverless)
- **Database**: 
  - **Slices 1-3**: localStorage (5MB, ~20-30 weeks capacity)
  - **Slice 4+**: Firebase Firestore (unlimited, multi-device sync)
- **AI**: Claude Sonnet 4.5 (via Anthropic API)
- **Authentication**: None (Slices 1-3), Firebase Auth (Slice 4+)
- **Hosting**: Vercel (static site + serverless functions)
- **Build**: None (no build step, direct ES modules)

---

## Non-Negotiables

1. **No build step** - Static site, direct ES modules
2. **Streaming responses** - SSE for chat, better UX
3. **Mobile-first** - Chat must work well on phones
4. **Offline viewing** - Saved data viewable offline
5. **Privacy** - API keys server-side only

---

## Questions to Answer After Each Slice

### After Slice 1:
- What was awkward in the implementation?
- What assumptions were wrong?
- What patterns should be standardized?
- Is the data shape right for Slice 2?

### After Slice 2:
- Is the generation flow smooth?
- Is the data model working?
- What needs refactoring before expanding?

### After Slice 3:
- Is the full data model stable?
- What UI patterns work best?
- Ready for polish phase?

---

## Project-Specific Patterns (Learned from Slices 1 & 2)

### Component Architecture
```javascript
export class ComponentName {
  constructor() {
    // Initialize state
  }
  
  // Optional lifecycle hooks
  beforeRender(state) {
    // Called before render
  }
  
  render(state) {
    // Return HTMLElement or string
    const container = document.createElement('div');
    // Build UI...
    return container;
  }
  
  afterRender(state) {
    // Called after render (good for async operations)
  }
  
  beforeUnload() {
    // Cleanup before component unmounts
  }
  
  destroy() {
    // Final cleanup
  }
}
```

### Storage Pattern
```javascript
// Always return data or sensible default (never throw)
export function loadData() {
  try {
    const saved = localStorage.getItem(KEY);
    if (saved) {
      const parsed = JSON.parse(saved);
      return Array.isArray(parsed) ? parsed : [];
    }
  } catch (error) {
    console.error('Error loading data:', error);
  }
  return []; // Always return default
}

// Always return result object
export function saveData(data) {
  if (!Array.isArray(data)) {
    return { success: false, error: 'INVALID_TYPE' };
  }
  return safeSave(KEY, data);
}
```

### SSE Streaming Pattern
```javascript
// Server-side: Send SSE messages
function sendSSE(writer, encoder, data) {
  const message = `data: ${JSON.stringify(data)}\n\n`;
  writer.write(encoder.encode(message));
}

// Client-side: Process SSE stream
async processStream(response) {
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';
  
  while (true) {
    const { value, done } = await reader.read();
    if (done) break;
    
    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';
    
    for (const line of lines) {
      if (!line.trim() || !line.startsWith('data: ')) continue;
      const data = JSON.parse(line.substring(6));
      // Handle data.type: 'progress', 'complete', 'error'
    }
  }
}
```

### Naming Conventions
- **Files**: Components use `PascalCase.js`, utilities use `camelCase.js`, APIs use `kebab-case.js`
- **localStorage Keys**: Standardize on `vanessa_` prefix (Slice 3)
- **IDs**: `recipe_[uuid]`, `meal_[uuid]`, `eater_[uuid]`, `plan_YYYYMMDD`

### UI/UX Patterns
- **Gradients**: Primary (`from-blue-400 to-indigo-400`), Success (`from-emerald-400 to-teal-400`)
- **Responsive**: Mobile-first, use `md:` breakpoint (768px)
- **Loading States**: Disable button + spinner + loading text


