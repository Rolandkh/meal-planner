# Product Requirements Document: Vanessa Chatbot - Meal Planning Assistant

## Project Overview

**Product Name:** Vanessa - AI Meal Planning Concierge
**Version:** v0.9 (Slice 3 Complete)
**Status:** Slices 1, 2 & 3 ‚úÖ Complete | Slice 4 Pending
**Approach:** Vertical Slice ‚Üí Reality Check ‚Üí Expand
**Technology Stack:** Vanilla JavaScript, HTML, CSS (Tailwind), Vercel serverless functions, Claude API

---

## Development Philosophy

This project follows an iterative "vertical slice" approach:

1. **Slice 1**: Build one complete end-to-end flow (chat with Vanessa) ‚úÖ **COMPLETE**
2. **Reality Check**: Evaluate what worked, what was awkward, update spec ‚úÖ **COMPLETE**
3. **Slice 2**: Add meal plan generation flow ‚úÖ **COMPLETE**
4. **Reality Check**: Evaluate and refine ‚úÖ **COMPLETE**
5. **Slice 3**: Recipe library, settings, onboarding ‚úÖ **COMPLETE**
6. **Reality Check**: Evaluate and refine ‚úÖ **COMPLETE**
7. **Slice 4+**: Expand features based on learnings
8. **Polish**: UI/UX improvements after core flows are stable

---

## SLICE 1: Chat with Vanessa (MVP Foundation) ‚úÖ COMPLETE

### Goal
Build a working chat interface where users can talk to Vanessa and conversations persist.

### End-to-End Flow
```
1. User opens app
2. User sees simple home page with chat button
3. User opens chat widget
4. User types a message
5. Message sent to /api/chat-with-vanessa
6. Vanessa responds with streaming text (SSE)
7. Response displays in real-time
8. Conversation saved to localStorage
9. On page reload, conversation history is restored
```

### What This Slice Includes

**Frontend Components:**
- `index.html` - App shell with Tailwind CSS
- `HomePage.js` - Simple landing with "Chat with Vanessa" button
- `ChatWidget.js` - Collapsible chat drawer with:
  - Message list (user + assistant messages)
  - Text input + send button
  - Typing indicator during streaming
  - Mobile: full-screen overlay
  - Desktop: side panel

**Backend:**
- `POST /api/chat-with-vanessa` - SSE streaming endpoint
  - Accepts: message, conversation history
  - Returns: Server-Sent Events stream
  - Uses Claude Sonnet API

**Data Storage (localStorage):**
- `conversation` - Array of messages with role, content, timestamp
- `baseSpecification` - Stub user profile (hardcoded for now)

**Utilities:**
- `src/utils/storage.js` - Save/load conversation
- `src/utils/state.js` - App state management
- `src/utils/router.js` - Simple hash-based router (/, /chat)

### What This Slice Does NOT Include
- Normalized data model (eaters, recipes, meals) - Slice 2
- Meal plan generation - Slice 2
- Onboarding flow - Slice 2
- Recipe library - Slice 3
- Usage metering - Slice 3
- Add recipe flow - Slice 4
- Offline mode - Slice 4
- Mobile polish - Final polish phase

### Technical Requirements for Slice 1

**Chat API Endpoint:**
```javascript
// POST /api/chat-with-vanessa
// Request:
{
  message: string,
  chatHistory: [{ role: 'user'|'assistant', content: string }]
}

// Response: Server-Sent Events
data: {"type": "token", "content": "Hi"}
data: {"type": "token", "content": " there!"}
data: {"type": "done"}
```

**Vanessa System Prompt (Slice 1 - Simple):**
```
You are Vanessa, a friendly meal planning assistant. 
Keep responses concise (2-3 sentences).
Help users think about their meal planning needs.
You cannot generate meal plans yet - that feature is coming soon.
```

**localStorage Structure (Slice 1):**
```javascript
{
  'vanessa_conversation': {
    messages: [
      { role: 'assistant', content: 'Hi! I\'m Vanessa...', timestamp: '...' },
      { role: 'user', content: 'Hello!', timestamp: '...' }
    ],
    startedAt: '2025-12-19T...'
  }
}
```

### Success Criteria for Slice 1
- ‚úÖ App loads with home page showing chat button
- ‚úÖ Clicking chat opens the chat widget
- ‚úÖ User can type and send a message
- ‚úÖ Vanessa responds with streaming text
- ‚úÖ Messages display in real-time as they stream
- ‚úÖ Conversation persists after page reload
- ‚úÖ Chat can be closed and reopened
- ‚úÖ Works on mobile (full-screen) and desktop (side panel)
- ‚úÖ Basic error handling (network errors show message)
- ‚úÖ "Generate Week" button always visible in chat
- ‚úÖ Auto-resize textarea as user types

### Known Unknowns (to evaluate after Slice 1)
- Is the streaming UX smooth enough?
- Is the chat widget responsive enough on mobile?
- Are there edge cases with SSE streaming?
- Is the conversation storage approach scalable?
- What patterns should be standardized before Slice 2?

---

## SLICE 2: Meal Plan Generation ‚úÖ COMPLETE

### Goal
Add the ability to generate a complete weekly meal plan with shopping list.

### End-to-End Flow (AS BUILT)
```
1. User chats with Vanessa about preferences (optional)
2. User clicks "‚ú® Generate Week" button (always visible in chat widget)
3. Chat widget closes automatically
4. App navigates to #/generating route
5. GenerationStatusPage displays with animated progress bar
6. SSE stream provides real-time progress updates (10% ‚Üí 25% ‚Üí 50% ‚Üí 75% ‚Üí 90% ‚Üí 95%)
7. Claude generates 7-day meal plan (21 meals: breakfast, lunch, dinner)
8. Response parsed, validated, and transformed to normalized format
9. Data saved to localStorage (recipes, meals, mealPlan)
10. Raw AI output saved to debug_raw_ai_output for debugging
11. Automatic redirect to home page showing meal plan summary
12. On failure: error message with "Retry" and "Start Over" buttons
```

### What This Slice Built

**Components:**
- ‚úÖ `GenerationStatusPage.js` - Full-featured progress UI with SSE streaming, retry logic, error handling
- ‚úÖ `MealPlanView.js` - Complete weekly meal plan display with expandable recipe details
- ‚úÖ `ShoppingListView.js` - Aggregated shopping list grouped by category with metric units
- ‚úÖ `HomePage.js` - Enhanced with meal plan summary cards and navigation buttons

**Backend API:**
- ‚úÖ `POST /api/generate-meal-plan` - Vercel Edge Runtime, SSE streaming
  - Uses Claude Sonnet 4.5 for generation
  - 90-second timeout (Vercel Edge limit)
  - Accepts: `chatHistory` (optional), `eaters` (optional, falls back to default)
  - Returns: SSE stream with progress updates and final meal plan JSON
  - Progress messages: "Analyzing preferences", "Planning week", "Creating recipes", etc.

**Data Transformation & Storage:**
- ‚úÖ `mealPlanTransformer.js` - Transforms Claude's raw JSON to normalized format
  - Recipe deduplication by name + ingredients hash
  - Generates unique IDs (recipe_uuid, meal_uuid, plan_YYYYMMDD)
  - Creates normalized recipes, meals, and mealPlan objects
  - Budget estimation based on recipe complexity
- ‚úÖ `storage.js` - localStorage persistence with quota handling
  - `recipes` - Array of unique Recipe objects
  - `meals` - Array of Meal objects (21 per week)
  - `currentMealPlan` - Active MealPlan object
  - `debug_raw_ai_output` - Raw AI response for debugging
  - Safe save wrapper with QUOTA_EXCEEDED error handling

**Shopping List System:**
- ‚úÖ `ShoppingListView.js` - Comprehensive aggregation system
  - Aggregates all ingredients from all recipes
  - Groups identical ingredients (with fuzzy matching for variations)
  - Converts ALL units to metric (grams/ml) or count (whole items)
  - Deduplicates across recipes
  - Categories: produce, meat, dairy, pantry, other
- ‚úÖ `unitConversions.js` - Extensive conversion mapping
  - 70+ ingredient-specific conversion rules
  - Imperial to metric conversions (cups‚Üíml, oz‚Üíg, lb‚Üíkg)
  - Count items preserved (eggs, onions, tomatoes)
  - Dual display for bread (loaves + slices)
  - Ingredient category classification
  - Fuzzy matching for ingredient variations

**Navigation & Routing:**
- ‚úÖ Updated router with 4 routes:
  - `#/` - HomePage (shows hero or meal plan summary)
  - `#/generating` - GenerationStatusPage (with progress)
  - `#/meal-plan` - MealPlanView (full week view)
  - `#/shopping-list` - ShoppingListView (aggregated list)

**Chat Integration:**
- ‚úÖ "Generate Week" button always visible in ChatWidget
- ‚úÖ Chat history passed to generation API for context
- ‚úÖ Last 10 messages used to inform meal plan preferences
- ‚úÖ System prompt instructs Claude to honor conversation constraints

**Error Handling:**
- ‚úÖ Network errors with user-friendly messages
- ‚úÖ JSON parse errors with fallback extraction
- ‚úÖ Storage quota errors with warnings
- ‚úÖ Retry mechanism on generation failure
- ‚úÖ "Start Over" option returns to home

**UI/UX Enhancements:**
- ‚úÖ Gradient backgrounds for different sections
- ‚úÖ Animated progress bar with emoji (üç≥)
- ‚úÖ Collapsible recipe details in meal plan
- ‚úÖ Checkboxes on shopping list (visual only, not functional yet)
- ‚úÖ Responsive design (mobile + desktop)
- ‚úÖ Loading states and disabled buttons during operations
- ‚úÖ Success/error feedback messages
- ‚úÖ Export raw AI output button for debugging

### Data Model (AS IMPLEMENTED)

**Recipe Object:**
```javascript
{
  recipeId: 'recipe_[uuid]',
  name: 'Recipe Name',
  ingredients: [
    {
      name: 'ingredient name',
      quantity: number,
      unit: 'g' | 'ml' | 'whole' | etc.,
      category: 'produce' | 'meat' | 'dairy' | 'pantry' | 'other'
    }
  ],
  instructions: 'Brief instructions (2-3 sentences max)',
  prepTime: number,        // minutes
  cookTime: number,        // minutes
  servings: number,
  tags: ['tag1', 'tag2'],
  source: 'generated',
  rating: null,
  createdAt: 'ISO 8601 timestamp'
}
```

**Meal Object:**
```javascript
{
  mealId: 'meal_[uuid]',
  recipeId: 'recipe_[uuid]',
  mealType: 'breakfast' | 'lunch' | 'dinner',
  date: 'YYYY-MM-DD',
  eaterIds: [],            // Empty for now, used in Slice 3
  servings: number,
  notes: ''
}
```

**MealPlan Object:**
```javascript
{
  _schemaVersion: 1,
  mealPlanId: 'plan_YYYYMMDD',
  weekOf: 'YYYY-MM-DD',    // Saturday start
  weekEnd: 'YYYY-MM-DD',   // Friday end
  createdAt: 'ISO 8601 timestamp',
  mealIds: ['meal_uuid1', 'meal_uuid2', ...],  // 21 meals
  budget: {
    target: 0,             // Not used yet
    estimated: number      // Calculated from recipes
  },
  weeklyPreferences: '',   // Empty for now
  conversation: {
    messages: []           // Empty for now, used in Slice 3
  }
}
```

### System Prompt (Meal Plan Generation)
```
You are Vanessa, an expert meal planning assistant. Generate a complete 7-day meal plan.

CRITICAL: Your response must be ONLY valid JSON in this EXACT format with NO additional text.

Guidelines:
- Generate exactly 7 days of meals (21 total: breakfast, lunch, dinner each day)
- Keep instructions BRIEF (2-3 sentences max per recipe)
- Include realistic estimated budget in dollars
- Consider user's dietary preferences and restrictions
- Vary recipes throughout the week
- Use 3-6 main ingredients per recipe (keep it simple)
- Focus on practical, quick recipes

CRITICAL - Units:
- Use ONLY metric units in ingredient quantities
- Liquids: milliliters (ml) or liters
- Solids: grams (g) or kilograms (kg)
- DO NOT use: ounces, pounds, cups, tablespoons, teaspoons
- Exception: Count items can use "whole" (e.g., "2 whole onions")
```

### What This Slice Does NOT Include (Deferred)
- Full onboarding flow (hardcoded default eater used)
- Eaters management UI
- Recipe library browsing
- Recipe favorites/ratings (data structure exists, UI pending)
- Usage metering/limits
- Edit/modify meal plan
- Regenerate single day
- Shopping list check-off persistence
- Export meal plan to PDF/markdown (debug export only)

---

## REALITY CHECK: Slice 2 Learnings

### What Worked Well ‚úÖ

1. **SSE Streaming for Progress**
   - Real-time progress updates provide excellent UX
   - Users see what's happening during 30-60 second generation
   - Pattern works well, should be reused for long operations

2. **Data Transformation Layer**
   - Clean separation between Claude's output and our storage format
   - Recipe deduplication works perfectly (hash-based on name + ingredients)
   - Easy to add validation and error handling in one place

3. **localStorage Strategy**
   - Simple, fast, no backend needed
   - Quota handling prevents silent failures
   - Debug output saved separately is invaluable for troubleshooting

4. **Unit Conversion System**
   - Comprehensive mapping handles 70+ ingredients
   - Metric-only shopping lists are clearer for Australian users
   - Fuzzy matching for ingredient variations works well

5. **Chat Context Integration**
   - Last 10 chat messages provide excellent context to Claude
   - Users can specify constraints ("30 ingredients max") and they work
   - No need for separate preference forms (yet)

6. **Component Lifecycle Hooks**
   - `afterRender()` hook perfect for triggering async operations
   - `beforeUnload()` for cleanup works well
   - Router's component pattern is flexible and simple

### What Was Awkward / Could Improve ü§î

1. **Shopping List Aggregation Complexity**
   - The aggregation logic is quite complex (300+ lines)
   - Multiple passes needed: collect ‚Üí aggregate ‚Üí convert ‚Üí dedupe
   - Hard to debug when ingredients don't combine as expected
   - **Learning**: Consider pre-processing ingredient names during generation

2. **Metric-Only Requirement**
   - System prompt says "metric only" but Claude sometimes forgets
   - We have fallback conversion, but adds complexity
   - **Learning**: May need stricter validation or retry logic

3. **Storage Keys Mix**
   - Some keys namespaced (`vanessa-chat-history`), some not (`recipes`, `eaters`)
   - Inconsistent naming convention
   - **Learning**: Standardize on `vanessa_` prefix for all keys in Slice 3

4. **No Eater Management Yet**
   - Hardcoded default eater works, but feels incomplete
   - Users can't specify household members yet
   - **Learning**: Slice 3 should add eater management before recipe library

5. **Error Messages Could Be Better**
   - Some errors just say "Generation failed"
   - No guidance on what to do (check internet? try again? contact support?)
   - **Learning**: Add more specific error types with actionable messages

6. **No Way to Modify Generated Plan**
   - If user doesn't like one recipe, they must regenerate entire week
   - **Learning**: Slice 3 or 4 should add "regenerate day" or "swap recipe" feature

### Technical Discoveries üîç

1. **Vercel Edge Runtime Limits**
   - 90-second timeout is hard limit
   - 8192 max_tokens usually sufficient for 7-day plan
   - Lower temperature (0.7) produces faster, more focused output

2. **Claude Sonnet 4.5 Performance**
   - Excellent at following JSON structure requirements
   - Occasionally adds markdown code fences (we strip them)
   - Honors conversation context very well
   - Budget estimates are reasonable but not accurate

3. **localStorage Quota**
   - ~5MB limit sufficient for multiple weeks
   - One week = ~50-100KB (recipes + meals + plan)
   - Could store 20-30 weeks before hitting quota
   - Debug output can fill quickly if not pruned

4. **Recipe Deduplication**
   - Hash-based approach works perfectly
   - Same recipe across multiple days correctly shares one Recipe object
   - Saves significant storage space

### Architecture Patterns Established üìê

1. **Data Flow:**
   ```
   User Intent ‚Üí Chat Widget ‚Üí API Endpoint ‚Üí Claude API
                                   ‚Üì
   Raw JSON ‚Üí Transformer ‚Üí Normalized Data ‚Üí localStorage
                                   ‚Üì
                          View Components ‚Üí Display
   ```

2. **Component Pattern:**
   - Each page is a class with `render()` method
   - Optional lifecycle hooks: `beforeRender()`, `afterRender()`, `beforeUnload()`
   - Components return HTMLElement or string
   - Router manages mounting/unmounting

3. **Error Handling:**
   - Try/catch at every async boundary
   - `ErrorHandler` utility for consistent messaging
   - Graceful degradation (show error, offer retry)
   - Log errors to console for debugging

4. **Storage Pattern:**
   - `load*()` functions return data or default (never throw)
   - `save*()` functions return result object with success/error
   - Validation happens before save
   - Atomic saves (all or nothing)

### Decisions Made üìù

1. **Week Start = Saturday**
   - Aligns with shopping day (Saturday morning)
   - Plan covers Sat ‚Üí Fri (7 days)
   - Hardcoded for now, could be user preference later

2. **Metric Units Only**
   - Australian market preference
   - Simpler for shopping (no cups/tbsp)
   - All conversions go one direction (imperial ‚Üí metric)

3. **No Database Yet**
   - localStorage sufficient for Phase 1
   - Defer Firebase/backend until usage metering needed (Slice 4)
   - Keeps deployment simple (static site)

4. **Chat History Context Limit**
   - Last 10 messages passed to generation
   - Enough for recent context, not too much tokens
   - Prevents prompt bloat

5. **Debug Output Saved**
   - Raw AI output saved to `debug_raw_ai_output`
   - Single key (overwrites each generation)
   - Export button on home page for debugging

### Ready for Slice 3? ‚úÖ

**Prerequisites Met:**
- ‚úÖ Core generation flow works end-to-end
- ‚úÖ Data model is stable and proven
- ‚úÖ Storage layer is robust
- ‚úÖ UI patterns established

**What Slice 3 Needs:**
1. Eater management (add/edit household members)
2. Preference settings (dietary restrictions, allergies)
3. Recipe library view (browse saved recipes)
4. Recipe detail view with favorites/ratings
5. Conversation history saved to meal plan
6. Standardize storage keys

**Blockers:** None. Ready to proceed.

---

## SLICE 3: Eaters, Profile & Recipe Library ‚úÖ COMPLETE

### Goal
Add household member management, user profile system, and recipe browsing capabilities.

### End-to-End Flow (PLANNED)
```
FLOW A: First-Time User Onboarding
1. User opens app (no profile exists)
2. Sees welcome message: "Chat with Vanessa to get started"
3. Opens chat widget
4. Vanessa asks 5-6 essential onboarding questions:
   - Dietary goals/restrictions
   - Household members (eaters)
   - Weekly budget
   - Shopping day
5. Profile auto-saves as conversation progresses
6. After final question: "You're all set! Click Generate Week when ready."
7. User can now generate meal plans

FLOW B: Eater Management
1. User navigates to #/settings
2. Sees "Household" section with list of eaters
3. Clicks "+ Add Member" button
4. Fills form: name, preferences, schedule, allergies
5. Saves ‚Üí new eater added to household
6. Can edit/delete existing eaters
7. Future meal plans consider all household members

FLOW C: Recipe Library
1. User navigates to #/recipes (new nav link)
2. Sees grid of all saved recipes
3. Can search by name/ingredient
4. Can filter: All / Favorites / High-Rated / Most Cooked
5. Clicks recipe card ‚Üí navigates to recipe detail
6. In detail view: see full recipe, toggle favorite, rate 1-5 stars
7. Back button returns to library

FLOW D: Profile Editing
1. User navigates to #/settings
2. Sees sections: Household, Meal Planning, Chat Preferences
3. Can edit: weekly budget, shopping day, dietary goals
4. Changes save immediately (or with Save button)
5. Success toast: "Profile updated"
```

### What This Slice Builds

**New Pages/Components:**
- ‚úÖ `SettingsPage.js` - Unified settings/profile page
  - Household section with eater CRUD
  - Meal planning preferences (budget, shopping day)
  - Chat preferences (personality, communication style)
- ‚úÖ `RecipeLibraryPage.js` - Browse saved recipes
  - Search bar (searches name, ingredients, tags)
  - Filter dropdown (All, Favorites, High-Rated, Most Cooked)
  - Recipe grid with cards
  - Recipe count display
- ‚úÖ `RecipeDetailPage.js` - Individual recipe view
  - Full recipe display
  - Star rating system (1-5 stars, clickable)
  - Favorite toggle button
  - Usage stats (times cooked, last cooked)
  - Servings, prep/cook time
  - Back button to library

**New Data Entities:**
- ‚úÖ `Eater` - Household member
  ```javascript
  {
    eaterId: 'eater_[uuid]',
    name: string,
    preferences: string,
    allergies: string[],
    dietaryRestrictions: string[],
    schedule: string,
    isDefault: boolean,
    createdAt: 'ISO 8601',
    updatedAt: 'ISO 8601'
  }
  ```

- ‚úÖ `BaseSpecification` - User profile
  ```javascript
  {
    _schemaVersion: 1,
    ownerEaterId: 'eater_[uuid]',
    weeklyBudget: number,
    shoppingDay: 0-6,  // 0=Sunday, 6=Saturday
    preferredStore: string,
    householdEaterIds: ['eater_[uuid]', ...],
    dietaryGoals: string,
    onboardingComplete: boolean,
    conversation: {
      startedAt: 'ISO 8601',
      messages: [{role, content, timestamp}]
    },
    createdAt: 'ISO 8601',
    updatedAt: 'ISO 8601'
  }
  ```

**Enhanced Existing Entities:**
- ‚úÖ Update `Recipe` with rating/favorite fields (already in data model, now add UI)
  - `isFavorite: boolean` - Toggle in recipe detail
  - `rating: number | null` - 1-5 star rating
  - `timesCooked: number` - Auto-increment when meal plan used
  - `lastCooked: 'ISO 8601' | null` - Track last usage

**Chat Integration:**
- ‚úÖ Onboarding conversation flow
  - Vanessa asks 5-6 questions on first visit
  - Stores responses in BaseSpecification
  - Marks onboardingComplete when done
- ‚úÖ Profile update conversations
  - User: "I want to change my budget to $200"
  - Vanessa: "I'll update your budget to $200. Confirm?"
  - User: "Yes"
  - Vanessa updates baseSpecification.weeklyBudget

**Storage Updates:**
- ‚úÖ **Standardize localStorage keys** (fix inconsistency from Slice 2):
  - `vanessa_chat_history` (already has prefix)
  - `vanessa_recipes` (rename from `recipes`)
  - `vanessa_meals` (rename from `meals`)
  - `vanessa_current_meal_plan` (rename from `currentMealPlan`)
  - `vanessa_eaters` (new)
  - `vanessa_base_specification` (new)
  - `vanessa_debug_raw_output` (rename from `debug_raw_ai_output`)

- ‚úÖ **Add storage utilities** (new functions in `storage.js`):
  ```javascript
  // Quota monitoring
  getStorageQuota() ‚Üí { used, limit, percentUsed, remaining, warning }
  
  // Export/Import
  exportAllData() ‚Üí downloads JSON file
  importAllData(file) ‚Üí restores from JSON
  
  // Cleanup
  clearOldMealPlans(keepWeeks=4) ‚Üí removes old data
  deleteOrphanedRecipes() ‚Üí removes unused recipes
  ```

- ‚úÖ **Add UI for storage management** (in Settings page):
  - Storage stats display (X MB / 5 MB used)
  - Warning banner when >80% full
  - Export button (download backup)
  - Import button (restore from file)
  - Cleanup button (clear old weeks)

**Navigation Updates:**
- ‚úÖ Add nav links (in header or sidebar):
  - Home (#/)
  - Recipes (#/recipes) - NEW
  - Shopping List (#/shopping-list)
  - Settings (#/settings) - NEW
- ‚úÖ Add routes:
  - `#/recipes` ‚Üí RecipeLibraryPage
  - `#/recipe/:id` ‚Üí RecipeDetailPage
  - `#/settings` ‚Üí SettingsPage

**Generation Updates:**
- ‚úÖ Pass eaters to generation API
  - Load eaters from storage
  - Include in POST body: `{chatHistory, eaters: [...]}`
  - Claude considers all household members
- ‚úÖ Save conversation with meal plan
  - Store last 10 chat messages in mealPlan.conversation

**Vanessa System Prompt Updates:**
- ‚úÖ Include base specification context
- ‚úÖ Include eater information
- ‚úÖ Include recipe library stats
- ‚úÖ Profile update confirmation flow

### Onboarding Flow Specification

**First Visit Detection:**
```javascript
// On app load
const baseSpec = loadBaseSpecification();
if (!baseSpec || !baseSpec.onboardingComplete) {
  // Show onboarding state
  chatWidget.open();
  chatWidget.showWelcomeMessage();
}
```

**Onboarding Questions (Vanessa asks):**
1. **Dietary Goals**
   - "What are your main dietary goals? (e.g., lose weight, eat healthier, follow a specific diet)"
   - Store in: `baseSpec.dietaryGoals`

2. **Food Restrictions**
   - "Are there any foods you don't eat or want to avoid?"
   - Create owner eater, store in: `eater.preferences`

3. **Household Members**
   - "Do you cook for anyone else, like family members with different preferences?"
   - If yes: "Tell me about them (names, ages, preferences)"
   - Create additional eaters

4. **Weekly Budget**
   - "What's your weekly grocery budget?"
   - Store in: `baseSpec.weeklyBudget`

5. **Shopping Day**
   - "Which day do you usually do your grocery shopping?"
   - Store in: `baseSpec.shoppingDay` (0-6)

6. **Confirmation**
   - "Perfect! You're all set. Click Generate Week whenever you're ready to create your first meal plan."
   - Set: `baseSpec.onboardingComplete = true`

**Progressive Enhancement (Future):**
- After first meal plan, Vanessa can ask optional questions:
  - Preferred grocery store
  - Eating window (intermittent fasting)
  - Cooking skill level
  - Time available for cooking

### Recipe Library Features

**Search Functionality:**
- Real-time search (debounced 300ms)
- Searches: recipe name, ingredients, tags
- Case-insensitive
- Highlights matches (future enhancement)

**Filter Options:**
```javascript
const filters = {
  'all': (recipe) => true,
  'favorites': (recipe) => recipe.isFavorite === true,
  'high-rated': (recipe) => recipe.rating >= 4,
  'most-cooked': (recipe) => recipe.timesCooked >= 3
};
```

**Sort Order:**
- Default: Most cooked first (descending)
- Then: Alphabetical by name

**Recipe Card Display:**
```javascript
{
  recipeImage: 'üçΩÔ∏è', // Emoji placeholder
  recipeName: string,
  cookTime: number + ' min',
  servings: number + ' servings',
  rating: '‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ' (1-5 stars),
  favoriteIndicator: '‚ù§Ô∏è' if isFavorite,
  timesCooked: 'Cooked X times'
}
```

**Empty States:**
- No recipes yet: "No recipes in your library yet. Generate a meal plan to add recipes!"
- No search results: "No recipes match '{query}'. Try a different search."
- No favorites: "You haven't favorited any recipes yet."

### Recipe Detail Features

**Display Sections:**
1. **Header**
   - Recipe name (large)
   - Favorite toggle button (heart icon)
   - Star rating (clickable stars)
   - Back button

2. **Meta Info**
   - Prep time, cook time, total time
   - Servings
   - Source (generated/user/imported)
   - Times cooked, last cooked

3. **Ingredients**
   - Grouped by category (produce, meat, dairy, pantry)
   - Quantity + unit + name
   - Checkbox (for shopping list, future)

4. **Instructions**
   - Step-by-step
   - Numbered list
   - Clear, concise

5. **Tags**
   - Clickable tag chips
   - Example: "quick", "healthy", "vegetarian"

6. **Usage History** (future)
   - "Used in meal plans: [dates]"

**Interactions:**
- Click star ‚Üí Update rating, save to storage, re-render
- Click heart ‚Üí Toggle favorite, save to storage, re-render
- Click back ‚Üí Navigate to #/recipes

### Storage Management Features (New in Slice 3)

**Storage Quota Monitoring:**
```javascript
// Add to storage.js
export function getStorageQuota() {
  let totalBytes = 0;
  
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    const value = localStorage.getItem(key);
    totalBytes += (key.length + value.length) * 2; // UTF-16 = 2 bytes per char
  }
  
  const limitBytes = 5 * 1024 * 1024; // 5MB
  const percentUsed = (totalBytes / limitBytes) * 100;
  
  return {
    usedBytes: totalBytes,
    usedMB: (totalBytes / 1024 / 1024).toFixed(2),
    limitMB: 5,
    percentUsed: percentUsed.toFixed(1),
    remainingMB: ((limitBytes - totalBytes) / 1024 / 1024).toFixed(2),
    warning: percentUsed > 80 ? 'critical' : percentUsed > 60 ? 'warning' : 'ok'
  };
}
```

**Export All Data:**
```javascript
export function exportAllData() {
  const data = {
    _exportVersion: 1,
    exportedAt: new Date().toISOString(),
    appVersion: '0.8',
    data: {
      chatHistory: loadChatHistory(),
      eaters: loadEaters(),
      recipes: loadRecipes(),
      meals: loadMeals(),
      currentMealPlan: loadCurrentMealPlan(),
      baseSpecification: loadBaseSpecification()
    }
  };
  
  const json = JSON.stringify(data, null, 2);
  const blob = new Blob([json], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `vanessa-backup-${new Date().toISOString().split('T')[0]}.json`;
  a.click();
  URL.revokeObjectURL(url);
  
  return { success: true, size: json.length };
}
```

**Import Data:**
```javascript
export async function importAllData(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      try {
        const imported = JSON.parse(e.target.result);
        
        // Validate version
        if (imported._exportVersion !== 1) {
          throw new Error('Incompatible backup version');
        }
        
        // Restore all data
        const data = imported.data;
        saveChatHistory(data.chatHistory || []);
        saveEaters(data.eaters || []);
        saveRecipes(data.recipes || []);
        saveMeals(data.meals || []);
        saveCurrentMealPlan(data.currentMealPlan);
        saveBaseSpecification(data.baseSpecification);
        
        resolve({ 
          success: true, 
          imported: Object.keys(data).length,
          exportedAt: imported.exportedAt 
        });
      } catch (error) {
        reject({ success: false, error: error.message });
      }
    };
    
    reader.onerror = () => reject({ success: false, error: 'File read error' });
    reader.readAsText(file);
  });
}
```

**Clear Old Data:**
```javascript
export function clearOldMealPlans(keepMostRecent = 4) {
  // TODO: When we support multiple meal plans in Slice 4
  // For now, just provide interface
  return {
    success: true,
    cleared: 0,
    kept: 1,
    spaceSaved: 0
  };
}

export function deleteOrphanedRecipes() {
  const recipes = loadRecipes();
  const meals = loadMeals();
  
  // Get all recipe IDs currently in use
  const usedRecipeIds = new Set(meals.map(m => m.recipeId));
  
  // Find orphaned recipes
  const orphaned = recipes.filter(r => !usedRecipeIds.has(r.recipeId));
  
  if (orphaned.length === 0) {
    return { success: true, deleted: 0, remaining: recipes.length };
  }
  
  // Keep only used recipes
  const remaining = recipes.filter(r => usedRecipeIds.has(r.recipeId));
  const result = saveRecipes(remaining);
  
  return {
    success: result.success,
    deleted: orphaned.length,
    remaining: remaining.length,
    orphanedNames: orphaned.map(r => r.name)
  };
}
```

**UI Components:**
- Storage stats card in Settings page
- Warning banner when >80% full
- Export/Import buttons
- Cleanup button with confirmation dialog

### Settings Page Features

**Layout:**
Four sections (tabs or accordion):

**1. Storage Section** (NEW)
- **Storage Stats Card:**
  - Progress bar showing X MB / 5 MB used
  - Percentage indicator
  - Color coding: green (<60%), yellow (60-80%), red (>80%)
  
- **Backup & Restore:**
  - Export button: "Download Backup" ‚Üí saves JSON file
  - Import button: "Restore from Backup" ‚Üí file picker
  - Last backup date display
  
- **Data Cleanup:**
  - "Delete Old Meal Plans" button
    - Dropdown: Keep last [4] weeks
    - Shows: "Will delete X weeks, save Y MB"
  - "Remove Unused Recipes" button
    - Shows: "X orphaned recipes found"
  - Confirmation dialogs before deletion

**2. Household Section**
- **Owner Eater**
  - Name (editable)
  - Dietary goals/preferences
  - Edit button

- **Other Members**
  - List of household members
  - Each shows: name, preferences summary
  - Edit / Delete buttons
  - "+ Add Member" button

- **Add/Edit Eater Modal/Form:**
  ```javascript
  {
    name: string (required),
    preferences: string (textarea),
    allergies: string[] (tags or comma-separated),
    dietaryRestrictions: string[] (tags or comma-separated),
    schedule: string (textarea),
    isDefault: boolean (checkbox for owner)
  }
  ```

**3. Meal Planning Section**
- Weekly budget (number input with $ prefix)
- Shopping day (dropdown: Sunday-Saturday)
- Preferred store (text input, optional)
- Dietary goals (textarea)

**4. Chat Preferences Section** (optional for Slice 3)
- Vanessa personality: Friendly, Professional, Casual
- Communication style: Concise, Detailed
- Reset onboarding button (re-triggers questions)

**Save Behavior:**
- Auto-save on blur for most fields
- Immediate save for storage operations (export, import, cleanup)
- Success toast: "Settings saved ‚úì"
- Error toast: "Save failed. Please try again."

**Save Behavior:**
- Auto-save on blur (for text inputs)
- OR single "Save Changes" button at bottom
- Success toast: "Settings saved ‚úì"

### Data Migration

**From Slice 2 to Slice 3:**
```javascript
// Run on first load of Slice 3
function migrateToSlice3() {
  // 1. Rename storage keys
  renameKey('recipes', 'vanessa_recipes');
  renameKey('meals', 'vanessa_meals');
  renameKey('currentMealPlan', 'vanessa_current_meal_plan');
  renameKey('debug_raw_ai_output', 'vanessa_debug_raw_output');
  
  // 2. Create default eater if none exists
  if (!loadEaters().length) {
    const defaultEater = {
      eaterId: 'eater_' + crypto.randomUUID(),
      name: 'User',
      preferences: 'no restrictions',
      allergies: [],
      dietaryRestrictions: [],
      schedule: 'home for dinner',
      isDefault: true,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    saveEaters([defaultEater]);
  }
  
  // 3. Create base specification if none exists
  if (!loadBaseSpecification()) {
    const eaters = loadEaters();
    const ownerEater = eaters.find(e => e.isDefault) || eaters[0];
    
    const baseSpec = {
      _schemaVersion: 1,
      ownerEaterId: ownerEater.eaterId,
      weeklyBudget: 150,
      shoppingDay: 6, // Saturday
      preferredStore: '',
      householdEaterIds: eaters.map(e => e.eaterId),
      dietaryGoals: '',
      onboardingComplete: false, // Will trigger onboarding
      conversation: {
        startedAt: new Date().toISOString(),
        messages: []
      },
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    saveBaseSpecification(baseSpec);
  }
  
  // 4. Add rating/favorite fields to existing recipes
  const recipes = loadRecipes();
  const updated = recipes.map(r => ({
    ...r,
    isFavorite: r.isFavorite ?? false,
    rating: r.rating ?? null,
    timesCooked: r.timesCooked ?? 0,
    lastCooked: r.lastCooked ?? null
  }));
  saveRecipes(updated);
  
  // 5. Set migration flag
  localStorage.setItem('vanessa_migration_slice3', 'complete');
}
```

**Storage Enhancements (localStorage + Features):**
- ‚úÖ **Storage Quota Monitoring**
  - Track localStorage usage (bytes used / 5MB limit)
  - Show warning banner at 80% capacity
  - Display storage stats in settings
  
- ‚úÖ **Export/Import Functionality**
  - Export all data to JSON file (complete backup)
  - Import from JSON file (restore data)
  - Download format: `vanessa-backup-YYYY-MM-DD.json`
  
- ‚úÖ **Data Cleanup Features**
  - Clear old meal plans (keep last 4 weeks)
  - Delete unused recipes (not in any meal plan)
  - Manual cleanup UI in settings
  - Show space saved after cleanup

**Storage Architecture Decision:**
- Continue with localStorage for Slice 3
- Quota: 5MB = ~20-30 weeks of data (sufficient)
- Migration to Firebase deferred to Slice 4 (when usage metering added)
- Storage abstraction layer makes future migration easy (1-2 days work)

### What This Slice Does NOT Include (Deferred to Slice 4+)

- ‚ùå Recipe import from URL
- ‚ùå Recipe import from pasted text
- ‚ùå Manual recipe creation form
- ‚ùå Usage metering / server-side limits
- ‚ùå Firebase/database migration
- ‚ùå Multi-device sync
- ‚ùå User authentication
- ‚ùå Upgrade prompts
- ‚ùå Pantry system
- ‚ùå Recipe editing after creation
- ‚ùå Meal plan history UI (data stored, no UI yet)
- ‚ùå Regenerate single day
- ‚ùå Export to PDF/calendar
- ‚ùå Advanced offline mode features

---

## REALITY CHECK: Slice 3 Learnings

**Date:** December 26, 2025  
**Version:** v0.9  
**Code Written:** ~4,500 lines (3,500 new + 1,000 enhanced)

### What Worked Exceptionally Well ‚úÖ

1. **Two-Phase AI Extraction System**
   - **Phase 1:** Extract structured schedule from conversation
   - **Phase 2:** Generate with explicit date-mapped requirements
   - **Result:** Claude now respects complex schedules accurately (Tuesday dinner = 3 servings, Thursday lunch = 1 serving)
   - **Learning:** Free-form conversation + structured extraction is the ideal UX
   - **Pattern Established:** AI conversations ‚Üí Structured data ‚Üí Explicit requirements

2. **Visual Feedback During Long Operations**
   - Typing indicators (`...`) prevent "is it broken?" moments
   - Progress messages show what's happening ("üë• Creating household profiles...")
   - Users understand the system is working
   - **Learning:** Visual feedback is critical for AI operations taking >2 seconds
   - **Pattern:** Always show progress for operations >1 second

3. **Household Schedule Grid**
   - Visual calendar showing who eats when (color-coded dots)
   - Instant clarity on complex schedules
   - Eliminates confusion about serving sizes
   - **Learning:** Visual representation > text description for schedules
   - **Pattern:** Use color-coding for multi-person scenarios

4. **AI-Powered Household Extraction**
   - Automatically creates profiles from conversation (Maya, Cathie, etc.)
   - Extracts ages, relationships, preferences
   - **Failsafe:** Creates profiles even if AI parsing fails (name detection)
   - **Learning:** Two-layer extraction (AI + regex fallback) ensures reliability
   - **Pattern:** Always have non-AI fallback for critical operations

5. **Ingredient Limit Constraint**
   - 46 items ‚Üí overwhelming
   - 30 items ‚Üí manageable
   - Constraint forces intelligent ingredient reuse
   - **Learning:** Constraints improve quality by forcing optimization
   - **Pattern:** Use limits to guide AI toward better solutions

6. **Voice-Activated Generation**
   - "Plan my week" auto-triggers generation
   - AI signals with marker, system detects and acts
   - No button click needed
   - **Learning:** Natural language commands improve UX
   - **Pattern:** AI can signal intent, system can act on signals

7. **Settings Page Architecture (4 Sections)**
   - Storage, Household, Meal Planning, Chat Preferences
   - 1,200+ lines but well-organized
   - Modal forms prevent page clutter
   - Auto-save with debounce (300ms)
   - **Learning:** Large components benefit from tab/section organization
   - **Pattern:** Modal forms + auto-save = cleaner UX

8. **Dev Presets for Testing**
   - Bypass 5-minute onboarding with 2-second preset load
   - Pre-configured household (Roland, Maya, Cathie)
   - Sample meal plan ready to test
   - **Learning:** Dev tools dramatically speed up iteration
   - **Pattern:** Always provide test data shortcuts for development

### What Was Awkward / Could Improve ü§î

1. **Date-to-Day Mapping Complexity**
   - Schedule uses day names (Sunday, Monday)
   - Generation uses dates (2025-12-29)
   - Must explicitly map in prompts ("TUESDAY Dec 31")
   - **Challenge:** Claude doesn't automatically know which date is which day
   - **Solution:** Explicit mapping in system prompt
   - **Future:** Consider having AI handle this mapping automatically

2. **AI API Call Costs**
   - Onboarding now uses 3 AI calls (chat + household extraction + schedule extraction)
   - Cost: ~$0.15 per onboarding (acceptable)
   - **Concern:** Cost grows with features
   - **Learning:** Monitor API usage carefully
   - **Future:** Consider caching common extractions

3. **localStorage Near Limits**
   - Rich profiles + schedules consume more space
   - Need active quota monitoring
   - **Current:** 5MB limit = ~20-30 weeks
   - **Learning:** localStorage sufficient for now, but migration to Firebase needed soon
   - **Pattern:** Monitor and warn early (60% = warning, 80% = critical)

4. **Browser Caching During Development**
   - Must hard-refresh to see updates
   - Can be frustrating during rapid iteration
   - **Learning:** Not an issue for users in production
   - **Pattern:** Add cache-busting for development builds

5. **Complex Prompts Getting Long**
   - Generation system prompt is now 200+ lines
   - Includes: schedule, eaters, constraints, examples
   - **Concern:** Token usage, maintainability
   - **Learning:** Long prompts are acceptable if results are good
   - **Future:** Consider prompt compression techniques

6. **Testing Blocked by API Quota**
   - Can't fully test until Jan 1, 2026
   - Built features based on theoretical understanding
   - **Learning:** Need test accounts with separate quotas
   - **Future:** Multiple API keys for testing vs. production

### Technical Discoveries üîç

1. **Structured Schedule Format**
   ```javascript
   weeklySchedule: {
     sunday: {
       breakfast: { servings: 1, eaterIds: ['eater_1'], requirements: 'Quick, kid-friendly' }
       // ...
     }
   }
   ```
   - Works perfectly for explicit requirements
   - Easy to map to dates during generation
   - Human-readable structure

2. **Smart EaterIds Assignment**
   - Transformer looks up schedule by date + mealType
   - Assigns correct eaterIds to each meal
   - Grid display automatically shows right dots
   - **Pattern:** Data structure enables UI automation

3. **Failsafe Household Creation**
   - If AI extraction fails, regex finds names
   - Always creates at least default profiles
   - Prevents onboarding failures
   - **Pattern:** Multiple extraction layers for reliability

4. **Component Modularity Win**
   - Built 4 major components in parallel
   - Each independently testable
   - Clean separation of concerns
   - **Learning:** Component architecture scales well

5. **Navigation Parameterized Routes**
   - `/recipe/:id` pattern works smoothly
   - Router extracts params correctly
   - Browser back/forward work properly
   - **Pattern:** Parameterized routes + hash routing = simple SPA

### Architecture Patterns Refined üìê

1. **AI Conversation ‚Üí Extraction ‚Üí Generation Flow:**
   ```
   User Conversation (Natural language)
        ‚Üì
   AI Extraction (Structured data)
        ‚Üì
   Explicit Requirements (Unambiguous specs)
        ‚Üì
   AI Generation (Constrained output)
        ‚Üì
   Display (User-facing)
   ```

2. **Two-Layer Extraction Pattern:**
   - Layer 1: AI extraction (best quality)
   - Layer 2: Regex fallback (guaranteed result)
   - Result: Reliability without sacrificing quality

3. **Modal Forms for Complex Inputs:**
   - Settings page uses modals for eater forms
   - Prevents page clutter
   - Focused user attention
   - Easier validation

4. **Auto-Save with Debounce:**
   ```javascript
   handleChange(field, value) {
     clearTimeout(this.saveTimeout);
     this.saveTimeout = setTimeout(() => {
       this.saveToStorage();
       this.showSuccessToast();
     }, 300);
   }
   ```
   - Smooth UX without explicit save buttons
   - Prevents excessive saves
   - Visual confirmation

5. **Dev Presets Pattern:**
   ```javascript
   if (isDevelopment && hasNoData) {
     showDevPresetButton();
   }
   ```
   - Visible only in development
   - One-click data loading
   - Dramatically speeds up testing

### Decisions Made üìù

1. **Ingredient Limit: 30 Items Default**
   - User-configurable (15-100)
   - Forces intelligent recipe reuse
   - Reduces shopping overwhelm
   - Can adjust based on household size

2. **Schedule-Driven Serving Sizes**
   - Each meal has explicit servings from schedule
   - No more assumptions
   - Accurate shopping lists
   - Grid display shows attendance

3. **Onboarding: Conversation over Forms**
   - Natural chat feels better than forms
   - AI extracts data automatically
   - Users can express nuances
   - More flexible than structured input

4. **Storage: Continue localStorage for Now**
   - Sufficient capacity (~20-30 weeks)
   - Zero cost
   - Offline-first
   - Migration to Firebase deferred to Slice 4

5. **Navigation: Single Header Bar**
   - Sticky at top
   - Mobile hamburger <768px
   - All major routes accessible
   - Active link highlighting

6. **Reality Check Format: Document in PRD**
   - Keep learnings in single source of truth
   - Easy to reference during Slice 4 planning
   - Informs future architectural decisions

### Ready for Slice 4? ‚úÖ

**Prerequisites Met:**
- ‚úÖ Core user flows complete (chat ‚Üí onboard ‚Üí generate ‚Üí view ‚Üí manage)
- ‚úÖ Data model stable and proven
- ‚úÖ Storage layer robust with monitoring
- ‚úÖ UI patterns established and consistent
- ‚úÖ Navigation system complete
- ‚úÖ Settings infrastructure ready for expansion
- ‚úÖ Migration system in place

**What Slice 4 Can Build On:**
1. Recipe import flows (URL, text, manual)
2. Recipe editing after creation
3. Meal plan history UI (browse past weeks)
4. Regenerate single day/meal
5. Firebase migration (multi-device sync)
6. Usage metering (track generations)
7. Advanced features (meal prep optimization, pantry)

**Blockers:** None. System is feature-complete for current scope.

**Testing Status:** Waiting for API quota reset (Jan 1, 2026) for full end-to-end testing.

---

## SLICE 4: Quick Wins & User-Requested Features

### Goal
Build the most requested features that provide immediate value without major infrastructure changes. Focus on recipe management, meal plan flexibility, and viewing history.

### Strategy
After Slice 3's complexity (AI extraction, migrations, settings), Slice 4 focuses on **quick wins** - features users will want immediately after onboarding. Each feature is relatively simple (1-2 days) and can ship independently.

### End-to-End Flows

**FLOW A: Edit a Recipe**
```
1. User views recipe detail page
2. Clicks "Edit Recipe" button
3. Form opens with all current values populated
4. User changes name, ingredients, or instructions
5. Clicks "Save" ‚Üí Recipe updates in storage
6. All meals using this recipe automatically reference updated version
7. Success toast: "Recipe updated ‚úì"
8. Page refreshes with new data
```

**FLOW B: Regenerate Single Day**
```
1. User views day or meal plan
2. Clicks "Regenerate Day" on a specific day (e.g., Tuesday)
3. Modal: "Regenerate Tuesday? This will create 3 new meals (breakfast, lunch, dinner)"
4. User confirms ‚Üí Navigate to generation status page
5. SSE stream shows progress (similar to full week generation)
6. Claude generates 3 meals for Tuesday only
7. System replaces Tuesday's meals, keeps other 18 meals
8. Updates shopping list automatically
9. Success ‚Üí Returns to meal plan view
```

**FLOW C: Browse Meal Plan History**
```
1. User navigates to new "History" page (#/history)
2. Sees list of past meal plans (cards with week dates)
3. Each card shows: week range, budget, meal count, creation date
4. User clicks a past week ‚Üí Views that week's meals (read-only)
5. Can view recipes, shopping list from that week
6. "Regenerate This Week" button creates new plan with same preferences
7. Back button returns to history list
```

**FLOW D: Import Recipe from Text**
```
1. User navigates to Recipe Library
2. Clicks "+ Add Recipe" button
3. Sees options: "Import from Text", "Create Manually" (Slice 5)
4. Selects "Import from Text"
5. Modal with large textarea: "Paste recipe here..."
6. User pastes recipe text from anywhere (blog, email, etc.)
7. Clicks "Import" ‚Üí Shows loading state
8. AI extracts structured recipe (name, ingredients, instructions, times)
9. Preview modal: "Does this look right?"
10. User confirms ‚Üí Recipe saved to library
11. Success toast: "Recipe added ‚úì"
12. Navigates to recipe detail page
```

### What This Slice Builds

#### 1. Recipe Editing System
**New Components:**
- `RecipeEditPage.js` - Edit form for existing recipes
- Pre-populated form with all current values
- Validation (required fields, ingredient quantities)
- Save ‚Üí Updates recipe in storage
- All meals automatically reference updated version (no ID change)

**Technical Details:**
- Route: `#/recipe/:id/edit`
- Reuses RecipeDetailPage validation logic
- Handles ingredient array updates (add/remove rows)
- Auto-save draft to localStorage (prevent data loss)
- "Discard Changes" confirmation dialog

**What Changes:**
- Recipe instructions, name, ingredients, prep/cook times
- NOT: recipeId (would break meal references)
- Updates `updatedAt` timestamp
- Preserves: rating, favorite, timesCooked, createdAt

#### 2. Regenerate Single Day System
**New Components:**
- "Regenerate Day" button in DayView and MealPlanView
- Confirmation modal with day name and meal count
- Modified generation flow (reuse GenerationStatusPage)

**Backend API:**
- Enhance `/api/generate-meal-plan` to accept `regenerateDay` param
- Generate only 3 meals for specified date
- Return same format as full week generation

**Data Handling:**
- Keep existing 18 meals (6 other days)
- Replace 3 meals for target day
- Update shopping list (aggregate all 21 meals)
- Update meal plan timestamps
- Remove orphaned recipes if unused

**UI Enhancements:**
- Add "Regenerate" icon button to each day card
- Modal: "Regenerate [Day]?" with meal preview
- Progress: "Regenerating Tuesday..." (not "Planning your week")
- Success: Navigate back to meal plan (not home)

#### 3. Meal Plan History System
**New Page:**
- `MealPlanHistoryPage.js` (#/history route)
- Lists all past meal plans from localStorage
- Card layout with week range, budget, meal count, date

**Data Structure:**
- New localStorage key: `vanessa_meal_plan_history`
- Array of MealPlan objects (archived)
- When generating new plan:
  1. Move `currentMealPlan` to history array
  2. Clean meals/recipes not in current plan
  3. Save new plan as current

**Storage Management:**
- Keep last 4 weeks by default (configurable in settings)
- Auto-cleanup on new generation
- Manual cleanup in Settings ‚Üí Storage section
- Show storage impact in quota monitor

**View Historical Plan:**
- Read-only view of past week
- Show all meals, recipes, shopping list
- No edit/regenerate options
- "Use as Template" button creates new plan with same structure

**Navigation:**
- Add "History" link to main navigation
- Badge showing count of saved plans
- Mobile: Include in hamburger menu

#### 4. Recipe Import from Text System
**New Components:**
- "Add Recipe" button in RecipeLibraryPage
- `RecipeImportModal.js` - Multi-step import flow
- Step 1: Choose method (Text / Manual)
- Step 2: Paste text or fill form
- Step 3: Preview extracted recipe
- Step 4: Confirm and save

**Backend API:**
- `POST /api/extract-recipe`
- Accepts: `text` (raw recipe string)
- Uses Claude to extract structure
- Returns: Recipe object (same format as generation)
- Error handling: "Could not extract recipe. Try manual entry."

**AI Extraction:**
```javascript
{
  input: "Recipe text from blog/email/etc.",
  output: {
    name: "Extracted Recipe Name",
    ingredients: [{name, quantity, unit}],
    instructions: "Step-by-step instructions",
    prepTime: 15,
    cookTime: 30,
    servings: 4,
    tags: ["extracted-tags"]
  }
}
```

**System Prompt for Extraction:**
```
Extract recipe data from the following text. Return ONLY valid JSON.

Guidelines:
- Extract name, ingredients, instructions, times, servings
- Convert ALL quantities to metric (g, ml, whole)
- If missing data, use reasonable defaults
- Instructions: clear, numbered steps
- Tags: cuisine type, dietary info, cooking method

Input text:
{user_pasted_text}
```

**Preview & Edit:**
- Show extracted recipe in preview modal
- User can edit before saving
- Validation: name and ingredients required
- Save ‚Üí Adds to recipe library
- Source: 'imported'

**Error Handling:**
- If extraction fails: offer manual entry
- If text is too short: "Please paste a complete recipe"
- If text is not a recipe: "This doesn't look like a recipe"

### What This Slice Does NOT Include (Deferred to Slice 5+)

- ‚ùå Recipe import from URL (fetch + extract)
- ‚ùå Manual recipe creation form (from scratch)
- ‚ùå Recipe duplicate/copy feature
- ‚ùå Share meal plan with others
- ‚ùå Print meal plan to PDF
- ‚ùå Export shopping list to apps (AnyList, etc.)
- ‚ùå Meal plan templates/favorites
- ‚ùå Nutrition information
- ‚ùå Firebase migration (Slice 6)
- ‚ùå Multi-device sync (Slice 6)
- ‚ùå Usage metering (Slice 6)
- ‚ùå Meal prep optimization (Slice 7)

### Success Criteria for Slice 4

**Recipe Editing:**
- ‚úÖ User can edit any recipe field
- ‚úÖ Changes save and persist
- ‚úÖ Meals automatically use updated recipe
- ‚úÖ No broken references

**Regenerate Day:**
- ‚úÖ User can regenerate any single day
- ‚úÖ Only 3 meals replaced (other 18 unchanged)
- ‚úÖ Shopping list updates correctly
- ‚úÖ Generation takes <60 seconds

**History:**
- ‚úÖ Past meal plans accessible
- ‚úÖ Can view all details (read-only)
- ‚úÖ Storage quota managed (auto-cleanup)
- ‚úÖ "Use as Template" creates similar plan

**Recipe Import:**
- ‚úÖ Can paste recipe text from anywhere
- ‚úÖ AI extracts structure accurately (>80% success rate)
- ‚úÖ Preview allows corrections
- ‚úÖ Recipe saves to library correctly

### Technical Requirements

**API Endpoints:**
```javascript
POST /api/generate-meal-plan
// New param: regenerateDay
{
  chatHistory: [],
  eaters: [],
  regenerateDay: 'tuesday' | null,  // NEW
  dateForDay: '2025-12-31'          // NEW: specific date to regenerate
}

POST /api/extract-recipe
{
  text: string  // Raw recipe text
}
// Returns: Recipe object
```

**localStorage Updates:**
```javascript
// New key
'vanessa_meal_plan_history': MealPlan[]  // Last 4 weeks

// Updated save pattern
function saveNewMealPlan(mealPlan) {
  // 1. Move current to history
  const current = loadCurrentMealPlan();
  if (current) {
    addToHistory(current);
  }
  
  // 2. Save new as current
  saveCurrentMealPlan(mealPlan);
  
  // 3. Cleanup old history (keep last 4)
  cleanupHistory(4);
}
```

**Routes:**
```javascript
'#/recipe/:id/edit' ‚Üí RecipeEditPage
'#/history' ‚Üí MealPlanHistoryPage
'#/history/:planId' ‚Üí MealPlanHistoryDetailPage (read-only)
```

### Implementation Strategy

**Week 1: Recipe Editing**
- Day 1-2: RecipeEditPage component
- Day 3: Validation and save logic
- Day 4: Testing and edge cases

**Week 2: Regenerate Single Day**
- Day 1-2: API enhancement for single day
- Day 3: UI buttons and confirmation modal
- Day 4: Integration and testing

**Week 3: Meal Plan History**
- Day 1-2: History page and storage
- Day 3: Auto-cleanup and quota management
- Day 4: View historical plan UI

**Week 4: Recipe Import**
- Day 1-2: API endpoint and AI extraction
- Day 3: Import modal and preview
- Day 4: Integration and testing

**Total: ~3-4 weeks for Slice 4**

---

## SLICE 5+: Future Features (Deferred)

### Slice 5: Recipe Management Pro
- Manual recipe creation (from scratch)
- Recipe import from URL
- Recipe duplication/copying
- Recipe categories and tagging
- Recipe notes and variations

### Slice 6: Firebase Migration & Sync
- Migrate to Firebase Firestore
- Firebase Authentication (anonymous + Google)
- Multi-device sync
- Usage metering (free tier: 4 generations/month)
- Cloud backup

### Slice 7: Meal Prep Optimization
- (Already fully spec'd in PRD above)
- Add prep preferences to settings
- Generate prep-aware recipes
- Build prep schedule generator
- Add prep UI components

---

## MEAL PREP OPTIMIZATION SYSTEM

### Overview
The meal prep system allows users to optimize their weekly cooking schedule by identifying batch-cooking opportunities, make-ahead meals, and prep day activities. This reduces daily cooking time while maintaining meal variety and freshness.

### User Meal Prep Strategies

Users can select their preferred meal prep style in Settings:

1. **Fresh Only** (Default)
   - Prepare each meal from raw ingredients before eating
   - Minimal advance preparation
   - Maximum freshness
   - Suitable for: Users with time each day, prefer fresh cooking

2. **Batch Cooking**
   - Dedicate 1-2 days per week to bulk meal preparation
   - Cook large quantities, portion, and store
   - Minimal daily cooking (mostly reheating/assembly)
   - Suitable for: Busy weekdays, prefer efficiency over daily cooking

3. **Hybrid** (Recommended)
   - Strategic mix of fresh and make-ahead
   - Prep components on designated days (e.g., Saturday)
   - Quick assembly on busy days, fresh cooking on lighter days
   - Suitable for: Most users, balanced approach

### Recipe Metadata for Prep Planning

**Enhanced Recipe Schema:**
```javascript
{
  recipeId: 'recipe_[uuid]',
  name: string,
  ingredients: [...],
  instructions: string,
  prepTime: number,
  cookTime: number,
  servings: number,
  
  // NEW: Meal prep fields
  prepStrategy: {
    type: 'fresh-only' | 'make-ahead' | 'batch-friendly' | 'components',
    storageTime: number,        // Days recipe keeps well (0-7)
    reheatTime: number,         // Minutes to reheat (if applicable)
    prepAheadInstructions: string,  // Special instructions for advance prep
    components: [               // For 'components' type
      {
        name: 'cooked chicken',
        prepTime: 20,
        storageTime: 3,
        usedIn: ['meal1', 'meal2']  // Which meals use this component
      }
    ]
  },
  
  complexity: 'simple' | 'moderate' | 'complex',  // Influences prep day scheduling
  tags: [..., 'quick-assembly', 'freezer-friendly', 'meal-prep'],
  
  // Existing fields
  source: 'generated' | 'user' | 'imported',
  rating: number | null,
  createdAt: 'ISO 8601'
}
```

### Prep Schedule Generation

**MealPlan Enhancement:**
```javascript
{
  _schemaVersion: 2,
  mealPlanId: 'plan_YYYYMMDD',
  weekOf: 'YYYY-MM-DD',
  weekEnd: 'YYYY-MM-DD',
  createdAt: 'ISO 8601',
  mealIds: [...],
  budget: {...},
  
  // NEW: Prep schedule
  prepSchedule: {
    prepDays: ['saturday'],  // User's designated prep days
    strategy: 'hybrid',      // User's selected strategy
    schedule: [
      {
        date: '2025-01-04',  // Saturday
        dayName: 'Saturday',
        isPrepDay: true,
        tasks: [
          {
            taskId: 'prep_task_1',
            type: 'batch-cook',
            name: 'Cook chicken breast (3 portions)',
            recipeIds: ['recipe_1', 'recipe_5'],  // Used in these recipes
            estimatedTime: 25,
            usedOn: ['2025-01-05', '2025-01-07', '2025-01-09'],  // Mon, Wed, Fri
            storageInstructions: 'Refrigerate in airtight container, use within 3 days',
            component: 'cooked chicken'
          },
          {
            taskId: 'prep_task_2',
            type: 'chop-vegetables',
            name: 'Chop vegetables (onions, peppers, carrots)',
            recipeIds: ['recipe_2', 'recipe_6', 'recipe_8'],
            estimatedTime: 15,
            usedOn: ['2025-01-05', '2025-01-06', '2025-01-08'],
            storageInstructions: 'Store in containers, use within 3-4 days'
          },
          {
            taskId: 'prep_task_3',
            type: 'make-ahead-meal',
            name: 'Prepare lasagna',
            recipeIds: ['recipe_10'],
            estimatedTime: 45,
            usedOn: ['2025-01-08'],  // Wednesday
            storageInstructions: 'Cover and refrigerate, bake Wednesday evening'
          }
        ],
        totalEstimatedTime: 85,  // minutes
        summary: '3 prep tasks for the week ahead'
      },
      {
        date: '2025-01-05',  // Monday
        dayName: 'Monday',
        isPrepDay: false,
        tasks: [],
        assemblyTasks: [
          {
            mealId: 'meal_1',
            mealType: 'dinner',
            recipeName: 'Chicken Stir Fry',
            assemblyTime: 10,
            instructions: 'Use prepped chicken and vegetables, stir-fry with sauce'
          }
        ],
        totalEstimatedTime: 25,  // Including assembly
        summary: 'Quick assembly using Saturday prep'
      }
      // ... other days
    ],
    weekSummary: {
      totalPrepTime: 85,           // Minutes on prep day
      averageDailyTime: 20,        // Average minutes per non-prep day
      timeSaved: 120,              // Estimated minutes saved vs. fresh cooking
      prepDayCount: 1,
      batchCookTasks: 2,
      makeAheadMeals: 1
    }
  },
  
  weeklyPreferences: string,
  conversation: {...}
}
```

### User Settings for Meal Prep

**BaseSpecification Enhancement:**
```javascript
{
  _schemaVersion: 2,
  ownerEaterId: 'eater_[uuid]',
  weeklyBudget: number,
  shoppingDay: 0-6,
  preferredStore: string,
  householdEaterIds: [...],
  dietaryGoals: string,
  onboardingComplete: boolean,
  
  // NEW: Meal prep preferences
  mealPrepPreferences: {
    strategy: 'fresh-only' | 'batch-cooking' | 'hybrid',  // Default: 'hybrid'
    prepDays: [6],           // Array of day indices (0=Sun, 6=Sat). Default: [6]
    maxPrepTime: 120,        // Max minutes willing to spend on prep day. Default: 120
    busyDays: [1, 2, 3, 4],  // Days that need quick meals (0=Sun). Default: weekdays
    lightDays: [0, 5, 6],    // Days with more time to cook. Default: weekends
    preferences: {
      preferFreshBreakfast: true,      // Always fresh breakfast. Default: true
      allowFrozenMeals: false,         // Use freezer for longer storage. Default: false
      batchCookingEnabled: true,       // Allow batch cooking of components. Default: true
      makeAheadMealsEnabled: true      // Allow fully prepared make-ahead meals. Default: true
    }
  },
  
  weeklySchedule: {...},
  chatPreferences: {...},
  conversation: {...},
  createdAt: 'ISO 8601',
  updatedAt: 'ISO 8601'
}
```

### AI Prompt Enhancement for Meal Prep

**Generation System Prompt Update:**
```
You are Vanessa, an expert meal planning assistant. Generate a complete 7-day meal plan
optimized for the user's meal prep strategy.

USER MEAL PREP PREFERENCES:
- Strategy: {strategy} (fresh-only | batch-cooking | hybrid)
- Prep Days: {prepDays} (e.g., Saturday)
- Busy Days: {busyDays} (e.g., Mon-Fri)
- Light Days: {lightDays} (e.g., weekends)
- Max Prep Day Time: {maxPrepTime} minutes
- Batch Cooking Enabled: {batchCookingEnabled}
- Make-Ahead Enabled: {makeAheadMealsEnabled}

MEAL PREP OPTIMIZATION RULES:

1. **For "fresh-only" strategy:**
   - All meals should be quick-cooking (< 30 min prep+cook)
   - Use simple recipes with minimal prep
   - No advance preparation required
   - Focus on fresh ingredients

2. **For "batch-cooking" strategy:**
   - Prioritize recipes that scale well and store well
   - Identify components that can be batch-cooked (proteins, grains, sauces)
   - Schedule complex recipes on prep day
   - Quick assembly meals on busy days (< 15 min)
   - Ensure all batch-cooked items used within safe storage time

3. **For "hybrid" strategy (RECOMMENDED):**
   - Balance of fresh and make-ahead
   - Batch-cook 2-3 key components on prep day (e.g., protein, grains, chopped vegetables)
   - Use prepped components in multiple meals throughout week
   - Fresh, simple meals on light days
   - Quick assembly meals on busy days
   - 1-2 fully make-ahead meals (e.g., casseroles, lasagna)

COMPONENT REUSE STRATEGY:
- If batch-cooking chicken, use in 2-3 different recipes (stir-fry, salad, wrap)
- If chopping vegetables, use across multiple days
- If making sauce/dressing, portion for multiple meals
- Ensure variety despite component reuse (different cuisines, flavor profiles)

PREP DAY SCHEDULE:
- Total prep time should not exceed {maxPrepTime} minutes
- Organize tasks by type (proteins ‚Üí vegetables ‚Üí assembly)
- Provide clear storage instructions
- Indicate which days/meals use each prepped component

BUSY DAY MEALS:
- Must be < 20 minutes total time on busy days
- Use prepped components for quick assembly
- Or use make-ahead meals that just need reheating
- Simple cooking methods (stir-fry, salad, sandwich, reheated casserole)

LIGHT DAY MEALS:
- Can be more complex, longer cooking time (30-60 min)
- Fresh cooking encouraged
- Opportunity for meal prep for upcoming week

STORAGE & SAFETY:
- Cooked proteins: 3-4 days refrigerated
- Chopped vegetables: 3-5 days refrigerated
- Cooked grains/pasta: 4-5 days refrigerated
- Fully prepared meals: 3-4 days refrigerated
- Soups/stews: 4-5 days refrigerated
- Indicate if recipe is freezer-friendly (2-3 months)

OUTPUT FORMAT:
For each recipe, include:
```json
{
  "name": "Recipe Name",
  "ingredients": [...],
  "instructions": "...",
  "prepTime": 15,
  "cookTime": 25,
  "servings": 4,
  "prepStrategy": {
    "type": "batch-friendly",  // or "make-ahead", "fresh-only", "components"
    "storageTime": 3,          // days
    "reheatTime": 5,           // minutes (if applicable)
    "prepAheadInstructions": "Cook chicken on Saturday, store in airtight container",
    "components": [            // if type is "components"
      {
        "name": "cooked chicken",
        "prepTime": 20,
        "storageTime": 3
      }
    ]
  },
  "complexity": "moderate",
  "tags": ["quick-assembly", "meal-prep", "batch-friendly"]
}
```

CRITICAL: Generate recipes that align with user's strategy and minimize daily cooking time
on busy days while maximizing variety and freshness.
```

### UI Components for Meal Prep

**1. Settings Page - Meal Prep Section**
```javascript
// New section in SettingsPage.js
<div class="meal-prep-section">
  <h2>Meal Prep Preferences</h2>
  
  <!-- Strategy Selection -->
  <div class="strategy-selector">
    <label>Meal Prep Strategy</label>
    <select name="strategy">
      <option value="fresh-only">Fresh Only (cook each meal)</option>
      <option value="hybrid" selected>Hybrid (recommended)</option>
      <option value="batch-cooking">Batch Cooking (prep days)</option>
    </select>
    <p class="help-text">Choose how you prefer to prepare meals</p>
  </div>
  
  <!-- Prep Days -->
  <div class="prep-days">
    <label>Prep Days</label>
    <div class="day-checkboxes">
      <label><input type="checkbox" value="0"> Sunday</label>
      <label><input type="checkbox" value="6" checked> Saturday</label>
    </div>
    <p class="help-text">Which days can you dedicate to meal prep?</p>
  </div>
  
  <!-- Max Prep Time -->
  <div class="max-prep-time">
    <label>Max Prep Time (minutes)</label>
    <input type="number" value="120" min="30" max="300" step="15">
    <p class="help-text">Maximum time you're willing to spend on prep day</p>
  </div>
  
  <!-- Busy Days -->
  <div class="busy-days">
    <label>Busy Days (need quick meals)</label>
    <div class="day-checkboxes">
      <label><input type="checkbox" value="1" checked> Mon</label>
      <label><input type="checkbox" value="2" checked> Tue</label>
      <label><input type="checkbox" value="3" checked> Wed</label>
      <label><input type="checkbox" value="4" checked> Thu</label>
      <label><input type="checkbox" value="5" checked> Fri</label>
    </div>
  </div>
  
  <!-- Advanced Options -->
  <div class="advanced-options">
    <label><input type="checkbox" checked> Allow batch cooking of components</label>
    <label><input type="checkbox" checked> Allow make-ahead meals</label>
    <label><input type="checkbox"> Use freezer for longer storage</label>
    <label><input type="checkbox" checked> Prefer fresh breakfast always</label>
  </div>
</div>
```

**2. Meal Plan View - Prep Schedule Tab**
```javascript
// New tab in MealPlanView.js
<div class="meal-plan-tabs">
  <button class="tab active">Weekly View</button>
  <button class="tab">Prep Schedule</button>  <!-- NEW -->
  <button class="tab">Shopping List</button>
</div>

<!-- Prep Schedule View -->
<div class="prep-schedule-view">
  <h2>Your Meal Prep Schedule</h2>
  
  <!-- Week Summary Card -->
  <div class="prep-summary-card">
    <h3>This Week's Prep Plan</h3>
    <div class="stats">
      <div class="stat">
        <span class="value">85 min</span>
        <span class="label">Prep Day Time</span>
      </div>
      <div class="stat">
        <span class="value">20 min</span>
        <span class="label">Avg Daily Time</span>
      </div>
      <div class="stat">
        <span class="value">2 hrs</span>
        <span class="label">Time Saved</span>
      </div>
    </div>
  </div>
  
  <!-- Prep Day Details -->
  <div class="prep-day-card">
    <div class="header">
      <h3>Saturday, January 4 - Prep Day</h3>
      <span class="time-badge">~85 minutes</span>
    </div>
    
    <!-- Prep Tasks -->
    <div class="prep-tasks">
      <div class="task">
        <div class="task-header">
          <span class="icon">üçó</span>
          <h4>Cook chicken breast (3 portions)</h4>
          <span class="time">25 min</span>
        </div>
        <p class="used-in">Used in: Mon dinner, Wed lunch, Fri dinner</p>
        <p class="storage">üì¶ Store in airtight container, refrigerate, use within 3 days</p>
      </div>
      
      <div class="task">
        <div class="task-header">
          <span class="icon">ü•ï</span>
          <h4>Chop vegetables (onions, peppers, carrots)</h4>
          <span class="time">15 min</span>
        </div>
        <p class="used-in">Used in: Mon dinner, Tue lunch, Thu dinner</p>
        <p class="storage">üì¶ Store in containers, refrigerate, use within 3-4 days</p>
      </div>
      
      <div class="task">
        <div class="task-header">
          <span class="icon">üçù</span>
          <h4>Prepare lasagna (make-ahead)</h4>
          <span class="time">45 min</span>
        </div>
        <p class="used-in">For: Wed dinner</p>
        <p class="storage">üì¶ Cover and refrigerate, bake Wednesday evening (30 min)</p>
      </div>
    </div>
  </div>
  
  <!-- Other Days -->
  <div class="regular-day-card">
    <h3>Monday, January 5</h3>
    <div class="assembly-tasks">
      <p class="quick-badge">‚ö° Quick Assembly Day</p>
      <div class="meal">
        <h4>Dinner: Chicken Stir Fry</h4>
        <p>Using: Prepped chicken + prepped vegetables</p>
        <span class="time">~10 min assembly</span>
      </div>
    </div>
  </div>
  
  <!-- ... more days ... -->
</div>
```

**3. Day View - Prep Status Indicators**
```javascript
// Enhancement to DayView.js
<div class="day-view">
  <h1>Monday, January 5</h1>
  
  <!-- Prep Status Banner (if applicable) -->
  <div class="prep-status-banner">
    ‚ö° Quick Day! Most ingredients prepped on Saturday. 
    Total cooking time today: ~25 minutes
  </div>
  
  <!-- Meal with prep indicators -->
  <div class="meal-card">
    <h2>Dinner: Chicken Stir Fry</h2>
    
    <!-- Prep Status -->
    <div class="prep-indicators">
      <span class="badge prepped">‚úì Chicken prepped</span>
      <span class="badge prepped">‚úì Vegetables prepped</span>
      <span class="badge fresh">Fresh: sauce, rice</span>
    </div>
    
    <div class="time-info">
      <span>Assembly: 10 min</span>
      <span>Cook rice: 15 min</span>
      <span>Total: 25 min</span>
    </div>
    
    <!-- Instructions adapted for prepped ingredients -->
    <div class="instructions">
      <h3>Instructions:</h3>
      <ol>
        <li>Cook rice (15 min)</li>
        <li>Get prepped chicken and vegetables from fridge</li>
        <li>Heat wok, stir-fry prepped ingredients (8 min)</li>
        <li>Add sauce, serve over rice</li>
      </ol>
    </div>
  </div>
</div>
```

**4. Recipe Detail Page - Prep Information**
```javascript
// Enhancement to RecipeDetailPage.js
<div class="recipe-detail">
  <h1>Chicken Stir Fry</h1>
  
  <!-- Prep Strategy Badge -->
  <div class="recipe-badges">
    <span class="badge batch-friendly">üîÑ Batch-Friendly</span>
    <span class="badge meal-prep">üì¶ Meal Prep</span>
    <span class="badge quick-assembly">‚ö° Quick Assembly</span>
  </div>
  
  <!-- Time Info with Prep Details -->
  <div class="time-breakdown">
    <div>
      <strong>If prepped:</strong> 10 min assembly
    </div>
    <div>
      <strong>From scratch:</strong> 35 min total
    </div>
  </div>
  
  <!-- Prep Ahead Instructions (collapsible) -->
  <div class="prep-ahead-section">
    <h3>Meal Prep Instructions</h3>
    <p><strong>Prep Day (Saturday):</strong></p>
    <ul>
      <li>Cook and dice chicken breast (20 min) - stores 3 days</li>
      <li>Chop vegetables (10 min) - stores 3-4 days</li>
    </ul>
    <p><strong>Day of (Monday):</strong></p>
    <ul>
      <li>Retrieve prepped chicken and vegetables</li>
      <li>Stir-fry with sauce (8 min)</li>
      <li>Serve over rice</li>
    </ul>
  </div>
</div>
```

### Implementation Priority

**Phase 1 (Foundation):**
1. Add meal prep preferences to BaseSpecification schema
2. Add meal prep UI section to Settings page
3. Update data migration to include new fields

**Phase 2 (Generation):**
1. Enhance AI prompt with meal prep optimization
2. Update Recipe schema with prepStrategy fields
3. Generate prep-aware recipes

**Phase 3 (Scheduling):**
1. Build prep schedule generator (analyze recipes, identify reusable components)
2. Add prepSchedule to MealPlan schema
3. Calculate time savings and efficiency metrics

**Phase 4 (UI):**
1. Add "Prep Schedule" tab to Meal Plan View
2. Add prep status indicators to Day View
3. Add prep badges and instructions to Recipe Detail
4. Show prep timeline and tasks

**Phase 5 (Polish):**
1. Add prep day reminders/notifications
2. Allow manual adjustment of prep schedule
3. Track actual vs. estimated prep time
4. Learn user's prep patterns over time

### Success Metrics

- **Time Efficiency:** Average daily cooking time reduced by 40-60% on busy days
- **User Satisfaction:** Users report meal prep reduces stress and decision fatigue
- **Adoption Rate:** 60%+ of users enable hybrid or batch-cooking strategy
- **Completion Rate:** 80%+ of users who set prep day preferences follow through

### Future Enhancements (Post-Slice 4)

- **Smart Prep Suggestions:** AI learns user's actual cooking patterns and adjusts
- **Leftover Integration:** Automatically plan meals using previous meals' components
- **Freezer Planning:** Extended prep for 2-4 weeks using freezer storage
- **Prep Day Calendar:** Sync prep tasks to Google Calendar with reminders
- **Prep Videos:** Video tutorials for batch cooking techniques
- **Nutrition Balancing:** Ensure prep strategy maintains nutritional goals

---

## Core Entities (As Implemented)

### Slice 1 Entities ‚úÖ
```javascript
// Conversation (chat history in localStorage)
// Key: 'vanessa-chat-history'
[
  {
    role: 'user' | 'assistant',
    content: string,
    timestamp: 'ISO 8601'
  }
]
```

### Slice 2 Entities ‚úÖ
```javascript
// Recipe (stored in 'recipes' key)
{
  recipeId: 'recipe_[uuid]',
  name: string,
  ingredients: [
    {
      name: string,
      quantity: number,
      unit: string,
      category: 'produce' | 'meat' | 'dairy' | 'pantry' | 'other'
    }
  ],
  instructions: string,
  prepTime: number,
  cookTime: number,
  servings: number,
  tags: string[],
  source: 'generated' | 'user' | 'imported',
  rating: number | null,
  createdAt: 'ISO 8601'
}

// Meal (stored in 'meals' key)
{
  mealId: 'meal_[uuid]',
  recipeId: 'recipe_[uuid]',
  mealType: 'breakfast' | 'lunch' | 'dinner',
  date: 'YYYY-MM-DD',
  eaterIds: string[],
  servings: number,
  notes: string
}

// MealPlan (stored in 'currentMealPlan' key)
{
  _schemaVersion: 1,
  mealPlanId: 'plan_YYYYMMDD',
  weekOf: 'YYYY-MM-DD',
  weekEnd: 'YYYY-MM-DD',
  createdAt: 'ISO 8601',
  mealIds: string[],
  budget: {
    target: number,
    estimated: number
  },
  weeklyPreferences: string,
  conversation: {
    messages: any[]
  }
}

// Debug Output (stored in 'debug_raw_ai_output' key)
{
  timestamp: 'ISO 8601',
  rawData: object  // Claude's raw JSON response
}
```

### Slice 3 Entities ‚úÖ (As Implemented)
```javascript
// Eater (stored in 'vanessa_eaters' key)
{
  eaterId: 'eater_[uuid]',
  name: string,
  preferences: string,
  allergies: string[],
  dietaryRestrictions: string[],
  schedule: string,
  isDefault: boolean,
  createdAt: 'ISO 8601',
  updatedAt: 'ISO 8601'
}

// BaseSpecification (stored in 'vanessa_base_specification' key)
{
  _schemaVersion: 1,
  ownerEaterId: 'eater_[uuid]',
  weeklyBudget: number,
  shoppingDay: 0-6,  // 0=Sunday, 6=Saturday
  preferredStore: string,
  maxShoppingListItems: number,  // NEW: 15-100, default 30
  householdEaterIds: ['eater_[uuid]'],
  dietaryGoals: string,
  onboardingComplete: boolean,
  weeklySchedule: {  // NEW: Structured schedule
    sunday: {
      breakfast: { servings, eaterIds, requirements },
      lunch: { servings, eaterIds, requirements },
      dinner: { servings, eaterIds, requirements }
    }
    // ... other days
  },
  chatPreferences: {
    personality: 'friendly' | 'professional' | 'casual',
    communicationStyle: 'concise' | 'detailed'
  },
  conversation: {
    startedAt: 'ISO 8601',
    messages: []
  },
  createdAt: 'ISO 8601',
  updatedAt: 'ISO 8601'
}

// Recipe (enhanced with Slice 3 fields)
{
  // ... existing fields ...
  isFavorite: boolean,        // NEW
  rating: number | null,      // NEW: 1-5 stars
  timesCooked: number,        // NEW: Usage tracking
  lastCooked: string | null,  // NEW: ISO 8601
  updatedAt: 'ISO 8601'       // NEW
}

// UsageLimits (deferred to Slice 4 - usage metering)
{
  plansGenerated: number,
  plansLimit: number,
  lastReset: 'ISO 8601',
  tier: 'free' | 'paid'
}
```

---

## High-Level Page List

| Page | Route | Slice | Status | Description |
|------|-------|-------|--------|-------------|
| Home | `#/` | 1 | ‚úÖ | Landing with chat button OR meal plan summary + day navigation |
| Chat (widget) | n/a | 1 | ‚úÖ | Collapsible chat drawer (always available) |
| Generation Status | `#/generating` | 2 | ‚úÖ | Progress UI during generation with SSE updates |
| Meal Plan View | `#/meal-plan` | 2 | ‚úÖ | Full week view with all meals and recipes |
| Day View | `#/day/:day` | 2 | ‚úÖ | Single day view with all meals for that day |
| Shopping List | `#/shopping-list` | 2 | ‚úÖ | Aggregated shopping list grouped by category |
| Recipe Library | `#/recipes` | 3 | ‚úÖ | Browse/search saved recipes |
| Recipe Detail | `#/recipe/:id` | 3 | ‚úÖ | Full recipe view with ratings |
| Settings | `#/settings` | 3 | ‚úÖ | User preferences and settings |
| Add Recipe | `#/add-recipe` | 4 | üìù | Import recipe flow |
| Prep Schedule | `#/prep-schedule` | 4+ | üìù | Meal prep schedule and tasks (NEW feature) |

---

## Critical Happy Paths

### Slice 1: Chat Flow
1. Open app ‚Üí See home page
2. Click "Chat with Vanessa" ‚Üí Chat opens
3. Type message ‚Üí Send
4. See streaming response ‚Üí Message complete
5. Close chat ‚Üí Reopen ‚Üí History preserved

### Slice 2: Generation Flow
1. Open chat ‚Üí Discuss preferences (optional)
2. Click Generate ‚Üí Navigate to status page
3. See progress bar ‚Üí Wait for completion
4. Success ‚Üí See meal plan
5. (If fail) ‚Üí Auto-retry ‚Üí (If fail again) ‚Üí Show options

### Slice 3: Onboarding Flow
1. First visit ‚Üí Chat auto-opens
2. Vanessa asks 5 questions (natural conversation)
3. User responds ‚Üí AI paraphrases with "you"
4. Vanessa shows summary + confirms
5. User: "Yes, let's do it" ‚Üí Auto-triggers generation
6. AI extracts household profiles (Maya, Cathie) + weekly schedule
7. Shows progress: "üë• Creating profiles..." "üìÖ Analyzing schedule..."
8. Generation starts automatically ‚Üí Meal plan ready
9. Grid displays who eats when (color-coded dots)
10. Shopping list constrained to 30 items (configurable in Settings)

---

## API Endpoints

| Endpoint | Slice | Status | Method | Runtime | Purpose |
|----------|-------|--------|--------|---------|---------|
| `/api/chat-with-vanessa` | 1 | ‚úÖ | POST | Edge | SSE streaming chat with Claude Sonnet 4.5 |
| `/api/generate-meal-plan` | 2 | ‚úÖ | POST | Edge | Generate 7-day meal plan with progress updates |
| `/api/extract-recipe` | 4 | üìù | POST | Edge | Extract recipe from URL or text |
| `/api/check-env` | - | ‚úÖ | GET | Edge | Development endpoint to verify API key |
| `/api/test-models` | - | ‚úÖ | GET | Edge | Development endpoint to test Claude models |

### API Details

#### POST /api/chat-with-vanessa
**Request:**
```json
{
  "message": "string (required)",
  "chatHistory": [
    {
      "role": "user | assistant",
      "content": "string"
    }
  ]
}
```

**Response:** SSE stream
```
data: {"type": "token", "content": "text"}
data: {"type": "token", "content": "more text"}
data: {"type": "done"}
```

**Errors:**
```
data: {"type": "error", "error": "Error message", "details": "..."}
```

**Configuration:**
- Model: `claude-sonnet-4-5-20250929`
- Max tokens: 1000
- Temperature: 0.7
- Timeout: 30 seconds
- System prompt: Concise, friendly meal planning assistant

#### POST /api/generate-meal-plan
**Request:**
```json
{
  "chatHistory": [
    {
      "role": "user | assistant",
      "content": "string"
    }
  ],
  "eaters": [
    {
      "name": "string",
      "preferences": "string",
      "schedule": "string"
    }
  ]
}
```

**Response:** SSE stream
```
data: {"type": "progress", "progress": 10, "message": "Analyzing preferences..."}
data: {"type": "progress", "progress": 25, "message": "Planning your week..."}
...
data: {"type": "complete", "data": { /* meal plan JSON */ }}
```

**Errors:**
```
data: {"type": "error", "error": "Error message"}
```

**Configuration:**
- Model: `claude-sonnet-4-5-20250929`
- Max tokens: 8192
- Temperature: 0.7
- Timeout: 90 seconds
- System prompt: Detailed meal plan generation with JSON output
- Returns: 7 days √ó 3 meals = 21 recipes with ingredients

---

## Tech Stack (Confirmed)

- **Frontend**: Vanilla JS (ES6 modules), HTML5, Tailwind CSS (CDN)
- **Backend**: Vercel Edge Functions (serverless)
- **Database**: 
  - **Slices 1-3**: localStorage (5MB, ~20-30 weeks capacity)
  - **Slice 4+**: Firebase Firestore (unlimited, multi-device sync)
- **AI**: Claude Sonnet 4.5 (via Anthropic API)
- **Authentication**: None (Slices 1-3), Firebase Auth (Slice 4+)
- **Hosting**: Vercel (static site + serverless functions)
- **Build**: None (no build step, direct ES modules)

---

## Non-Negotiables

1. **No build step** - Static site, direct ES modules
2. **Streaming responses** - SSE for chat, better UX
3. **Mobile-first** - Chat must work well on phones
4. **Offline viewing** - Saved data viewable offline
5. **Privacy** - API keys server-side only

---

## Questions to Answer After Each Slice

### After Slice 1:
- What was awkward in the implementation?
- What assumptions were wrong?
- What patterns should be standardized?
- Is the data shape right for Slice 2?

### After Slice 2:
- Is the generation flow smooth?
- Is the data model working?
- What needs refactoring before expanding?

### After Slice 3:
- Is the full data model stable?
- What UI patterns work best?
- Ready for polish phase?

---

## Project-Specific Patterns (Learned from Slices 1, 2 & 3)

### Component Architecture
```javascript
export class ComponentName {
  constructor() {
    // Initialize state
  }
  
  // Optional lifecycle hooks
  beforeRender(state) {
    // Called before render
  }
  
  render(state) {
    // Return HTMLElement or string
    const container = document.createElement('div');
    // Build UI...
    return container;
  }
  
  afterRender(state) {
    // Called after render (good for async operations)
  }
  
  beforeUnload() {
    // Cleanup before component unmounts
  }
  
  destroy() {
    // Final cleanup
  }
}
```

### Storage Pattern
```javascript
// Always return data or sensible default (never throw)
export function loadData() {
  try {
    const saved = localStorage.getItem(KEY);
    if (saved) {
      const parsed = JSON.parse(saved);
      return Array.isArray(parsed) ? parsed : [];
    }
  } catch (error) {
    console.error('Error loading data:', error);
  }
  return []; // Always return default
}

// Always return result object
export function saveData(data) {
  if (!Array.isArray(data)) {
    return { success: false, error: 'INVALID_TYPE' };
  }
  return safeSave(KEY, data);
}
```

### SSE Streaming Pattern
```javascript
// Server-side: Send SSE messages
function sendSSE(writer, encoder, data) {
  const message = `data: ${JSON.stringify(data)}\n\n`;
  writer.write(encoder.encode(message));
}

// Client-side: Process SSE stream
async processStream(response) {
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';
  
  while (true) {
    const { value, done } = await reader.read();
    if (done) break;
    
    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop() || '';
    
    for (const line of lines) {
      if (!line.trim() || !line.startsWith('data: ')) continue;
      const data = JSON.parse(line.substring(6));
      // Handle data.type: 'progress', 'complete', 'error'
    }
  }
}
```

### Naming Conventions
- **Files**: Components use `PascalCase.js`, utilities use `camelCase.js`, APIs use `kebab-case.js`
- **localStorage Keys**: Standardize on `vanessa_` prefix (Slice 3)
- **IDs**: `recipe_[uuid]`, `meal_[uuid]`, `eater_[uuid]`, `plan_YYYYMMDD`

### UI/UX Patterns
- **Gradients**: Primary (`from-blue-400 to-indigo-400`), Success (`from-emerald-400 to-teal-400`)
- **Responsive**: Mobile-first, use `md:` breakpoint (768px)
- **Loading States**: Disable button + spinner + loading text


